# 인덱스 탐색
: 두 단계로 이루어짐
1. 수직적 탐색 : 인덱스 스캔 시작지점을 찾는 과정
2. 수평적 탐색 : 데이터를 찾는 과정

### 인덱스 튜닝의 핵심
1. 인섹스 스캔과정에서 발생하는 비효율을 줄이는 것
2. 테이블 액세스 횟수를 줄이는 것 = 랜덤 액세스 최소화 튜닝(이부분이 더 중요)

# 인덱스 : 대용량 테이블에서 필요 데이터만 빠르게 효율적으로 접근하기 위해 사용하는 오브젝트

- ROWID : 데이터 블록주소 + 로우 번호
- 데이터 블록주소 = 데이터 파일번호 + 블록번호
- 블록번호 : 데이터 파일 내에서 부여한 상대적 순번
- 로우번호 : 블록 내 순번

### 인덱스 수직탐색의 목표지점은 '조건을 만족하는 첫번째 레코드'

### 인덱스를 수평탐색하는 이유
1. 조건절을 만족하는 데이터를 모두 찾기 위함
2. ROWID를 얻기 위함 : 일반적으로 인덱스스캔후 테이블에 접근하기 때문에 이때 필요함

### 인덱스 컬럼을 가공하지 않아야 인덱스를 정상사용할 수 있다
- 인덱스를 정상사용한다 = 리프 블록을 일부만 스캔하는 인덱스 레인지 스캔
- 인덱스 컬럼을 가공해도 인덱스를 사용할 수는 있지만 이때는 인덱스 풀스캔으로 동작한다 
    ㄴ 이유 : 인덱스 스캔 시작점을 찾을 수 없기 때문
- 인덱스를 레인지 스캔하기 위한 첫 조건은 인덱스 선두 컬럼이 조건절에 있어야 한다는 것. 가공하지 않은 상태로

### 자동 형변환(in oracle) : 의존하지 말것. 정확한 명시가 필요
- 숫자형 > 문자형 : 숫자형이 우선됨 but like 연산자에서는 문자형으로 바뀐다.
- 날짜형 > 문자형 : 날짜형이 우선됨

-----

## 인덱스 스캔방식
- Index Full Scan
- Index Unique Scan
- Index Skip Scan
- Index Fast Full Scan

## Index Full Scan
: B*tree 인덱스의 가장 일반적이고 정상적인 형태의 액세스 방식. 인덱스>리프블록까지 수직탐색 후 필요한 범위만 스캔

## Index Unique Scan
: 수직탐색 없이 인덱스 리프 블록을 처음~끝 수평적 탐색. 

## Index Skip Scan
: 수직탐색만으로 데이터를 찾는 스캔방식. 유니크 인덱스를 = 으로 탐색하는 경우에 작동. 데이터를 한건 찾는 순간 더 탐색할 필요가 없다

## Index Fast Full Scan
: 인덱스 선두컬럼을 조건절에 사용하지 않으면 옵티마이저는 기본적으로 테이블 풀스캔한다. 이때 고안된것 방법인데, 조건절에 빠진 인덱스 선두 컬럼의 distinct value갯수가 적고 후행컬럼의 distinct value갯수가 많을 때 유용하다 
- 루트 또는 브랜치 블록에서 읽은 컬럼값 정보를 이용해 조건절에 부합하는 레코드를 포함할 가능성이 있는 리프블록만 골라서 액세스하는 스캔방식
- 논리적인 인덱스 트리구조를 무시하고 인덱스세그먼트 전체를 멀티블록 아이오방식으로 스캔한다
- 물리적으로 디스크에 저장된 순서대로 인덱스 리프 블록들을 읽어들인다
- 멀티블록 아이오방식을 사용하므로 대량의 인덱스 블록을 읽을때 효과가 크다
- 인덱스 리프노드의 연결리스트 구조를 무시하기 때문에 결과집합이 인덱스 순서대로 정렬되지 않음
- 쿼리에 사용한 컬럼이 모두 인덱스에 포함되어 있을 때만 사용할수 있는 제약이 있음
- 인덱스가 파티션돼있지 않더라도 병렬쿼리가 가능


|Index Full Scan|Index Fast Full Scan|
|------|------|
|1. 인덱스 구조를 따라 스캔 | 1. 세그먼트 전체를 스캔|
|2. 결과집합 순서보장|2. 결과집합 순서보장안됨|
|3. Single Block I/O|3. Multi Block I/O|
|4. (파티션되어있지 않으면)병렬스캔불가|4. 병렬스캔가능|
|5.인덱스에 포함되지 않은 컬럼 조회시에도 사용가능|5. 인덱스에 포함된 컬럼으로만 조회할때 사용가능|


## Index Range Scan Descending
: Index Range Scan 과 기본적으로 동일. Descending할 뿐. index_desc 힌트로 유도가능