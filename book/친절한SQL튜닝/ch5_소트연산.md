# 소트연산
: 소트머지 조인, 해시조인, 데이터 소트, 그룹핑

### 특징
- 메모리 집약적
- cpu 집약적

### 소트 수행과정
: PGA에 할당한 sort area에서 이루어짐. 메모리공간인 sort area가 다 차면 디스크 temp 테이블 스페이스를 활용. sort area에서 작업이 완료되는지에 따라 소트의 유형이 두가지로 나뉜다

- 메모리소트(In-memory sort) : 전체 데이터의 정렬작업을 메모리 내에서 완료. internal sort라고도함
- 디스크소트(To-disk sort) : 할당받은 sort area 내에서 정렬을 완료하지 못해 디스크 공간까지 사용하는 경우를 말함. external sort라고도 함

1. 소트할 대상 집합을 SGA 버퍼캐시를 통해 읽어들임
2. 일차적으로 Sort area에서 정렬시도
3. 양이 많은 경우 sort area에서 정렬이 끝나지 않고 temp 테이블 스페이스에 임시 세그먼트를 만들어 저장한다
4. sort area가 찰때마다 temp 영역에 저장해둔 중간단계의 집합을 sort run이라고 부른다
5. 정렬된 최종 결과집합을 얻기 위해 merge한다. 이때 sort run안에서는 이미 정렬되어 있다.
6. 각각에서 값을 PGA로 읽어들이고 PGA가 차면 쿼리수행 다음단계로 전달 또는 클라이언트에게 전송하면 된다.

### 정렬된 그룹핑 결과를 얻고자 한다면 실행계획에 설령 'sort group by'라고 표시되어도 order by를 명시해야 한다.

### 서브쿼리 unnesting
: 옵티마이저가 서브쿼리를 풀어 일반 조인문으로 변환하는 것

### UNION < UNION ALL
: UNION 사용시 옵티마이저는 중복을 제거하기 위해 SORT 작업을 수행한다. UNION ALL은 중복작업을 확인하지 않고 단순 결합하므로 SORT 작업하지 않는다. 따라서 될수있으면 UNION ALL을 사용하는것이 낫다.

### EXISTS
: 중복레코드 제거시 DISTINCT를 많이 사용하는데 이 연산자를 사용하면 조건에 해당하는 데이터를 모두 읽어서 중복을 제거해야한다. 부분범위 처리가 불가능하고 모든 데이터를 읽으면서 IO가 많이 발생한다.

### 인덱스는 항상 키 컬럼순으로 정렬된 상태가 유지됨
: 활용하면  SQL에 ORDER BY나 GROUP BY 절이 있어도 소트연산을 생략할 수 있다.
