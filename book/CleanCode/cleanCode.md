## ch0_책의요지

## 책의 핵심 : 클린코드를 지향하는 이유. 클린코드를 위한 팀이나 공동체에서 서로 동의하는 합리적인 원칙을 세우기 위한 소통방법.

## 5s
1. Sort:정리. 정렬  => 적절한 명명법으로 정리
2. Section:정돈. 체계화 => 예상하는 위치에 예상된 코드가 있어야함
3. Seiso:청소. 광내기 => 과거이력, 미래바람, 주석으로 처리한 코드 삭제
4. Seiketsu:청결. 표준화 => 그룹이 동의한 방식으로 청소
5. shutsuke:생활화. 규율 => 관례를 따르고 또 변경에 유연할 것

## => 제품의 생명주기까지 고려할 줄 알아야 한다.

----------------------------------
## ch1_깨끗한 코드
1. 깨끗한 코드가 필요한 이유
   1. 르블랑의 법칙 : 나중은 결코 오지 않는다. 스파게티 코드를 고칠 시간은 없다.
2. 클린코드에 대한 다양한 개발자의 의견
   1. 자기 코드에 대한 장인정신을 가져야함

### ch1 결론 : 유지보수를 위해서는 처음에 잘 짜야한다. 나중에 고치자는 생각을 접고 최대한 장인정신을 가지고 코딩하자

### 내의견 적기
깃허브 코파일럿(코딩AI)은 요구사항을 정확히 이해해야 하는 인간의 상황을 알기 어려움   

----------------------------------
## ch2_의미있는 이름(네이밍)
1. 의도를 분명히 밝힐 것 
2. 그릇된 정보를 전달하지 않는 변수명 
   1. 일관성이 떨어지면 안된다
   2. i와 l, 0과 O의 혼동에 유의할 것
3. 의미있는 구분이 가능할 것 
4. 발음이 쉬울 것 
5. 검색하기 쉬울 것
6. 인코딩을 피할 것
   1. 헝가리식 표기법 
   2. 멤버변수 접두어 
      1. 함수와 클래스는 접두어가 필요없을 정도로 작아야 한다
   3. 인터페이스 클래스와 구현 클래스 
7. 자신의 기억력을 믿지 말것
8. 클래스명
   1. 명사/명사구가 적합
9. 메서드명
   1. 동사/동사구가 적합
10. 기발한 이름은 피할것
11. 한 개면에 한 단어를 사용할 것
    1. 일관성 있는 변수명 사용이 가독성을 높임
12. 말장난하지 말 것
13. 해법 영역에서 가져온 이름을 사용할 것
14. 문제 영역에서 가져온 이름을 사용할 것
15. 의미있는 맥락을 추가할 것
16. 불필요한 맥락을 없앨것

### ch2 결론 : 네이밍 룰을 정하고 따르는 것이 장기적으로 유지보수에 유리함. 직관적이고 통일적인 네이밍 사용권장.

### 내의견 적기
1. 변수/함수 네이밍에 대한 말장난은 다음 책에서 재미있게 볼수 있다
개인적으로 개발자의 깔깔유머집같은 느낌이라고 생각한다. 가볍게 웃으면서 볼수 있는 책이다

- 유지보수하기 어렵게 코딩하는 법 by 로에디 그린(부제: 평생 개발자로 먹고 살 수 있다)

2. 개발시에는 팀에서 관리하는 용어집이 있는게 좋더라
- gubun, kind, type 등 비슷한 경우에 어떤 단어를 선택할지 몰라 많은 시간이 허비된다.
- 공동 용어집이 있으면 기존에 어떤 단어를 사용했는지 알기가 훨씬 수월하다.

3. 매직넘버/매직리터럴의 사용을 피할 것
- 대부분 지역적/개인적으로 쓰이기 때문에 다른 개발자가 소스를 분석할 때 불편하다.

cf) 매직넘버와 매직리터럴
: 상수로 선언되지 않은 숫자/문자열을 말함
 ex) 
```
   if(state == 10)
   if(state == "ok")
```

 -매직넘버/스트링 제거시->
```
   if(state == NOISE_LEVEL)
   if(state == STATE_OK)
```

- 이런식으로 상수로 추출해 값이 어떤 항목인지 네이밍으로 명확하게 하고 관리도 중앙에서 할수 있는 방식이 장기적으로 유리하다.


----------------------------------

## ch3_함수
1. 작게 만들기
2. 한가지 기능만 할것
3. 함수당 추상화 수준은 하나로
   1. 위에서 아래로 내려가는 구현순서. 가독성
4. 서술적인 이름 사용
5. 함수인수
   1. 단항형식
   2. 플래그인수
   3. 이항함수
   4. 삼항함수
   5. 인수객체
   6. 인수목록
   7. 동사와 키워드
6. 부수 효과를 사용하지 말것
7. 명령과 조회의 분리
8. 오류코드보다 예외를 사용
   1. try/catch 블록 뽑아내기
   2. 오류처리도 한가지 작업
   3. Error.java 의존성 자석
9. 반복하지 말것
10. 구조적 프로그래밍
11. 함수를 짜는 법

### ch3 결론 : 함수는 작고 간결하게 구분지어 만들 것. 파라미터가 여러개인 함수는 이해하기 어렵다. 함수를 구분/단순화하자


### 내의견 적기
- 가능한 중복코드를 줄이고 함수를 구분하자. 물론 코딩하다보면 한 함수에 내용이 전부 구현되는게 편하긴한데..
바로 리팩토링을 해서라도 구분해놓는게 미래의 나/우리를 위해 좋다고 하니 노력하자

 ----------------------------------
## ch4_주석
1. 주석은 나쁜 코드를 보완하지 못한다.
2. 코드로 의도를 표현하기
3. 좋은 주석 : 극단적으로 표현하면, 코드가 명확하면 주석이 필요없다
   1. 법적인 주석
   2. 정보를 제공
   3. 의도를 설명
   4. 의미가 명료한 주석
   5. 결과를 경고하는 주석
   6. toDo주석
   7. 중요성을 강조
   8. 공개 api에서 javadocs
4. 나쁜주석
   1. 주절거리기
   2. 중복된 이야기
   3. 오해의 여지가 있는 주석
   4. 의무적으로 다는 주석
   5. 이력을 기록하는 주석 : GIT을 믿는다면 필요없다
   6. 있으나 마나한 주석
   7. 무서운 잡음 : ex) ----actions---- 등 주석으로 코드를 구분하는 경우. 
   8. 함수/변수로 표현할 수 있는 경우 주석을 달지 말것
   9. 위치를 표시하는 주석
   10. 닫는괄호에 다는 주석 : 함수가 긴 경우 유용하나 bracket 플러그인을 사용하거나 함수의 크기를 줄이는 방법을 먼저 생각하자
   11. 공로를 돌리거나/저자를 표시하는 주석
   12. 주석으로 처리한 코드 : 데드코드가 쌓여서 코드가 지저분진다.
   13. html 주석
   14. 전역정보
   15. 너무 많은 정보
   16. 모호한 관계
   17. 함수 헤더
   18. 비공개 코드에서 javaDocs

### ch4 결론 : 부정확한 주석은 없느니만 못하다 

### 내의견 적기
- 잘못 적힌 주석이나 의미없는 주석이 많은 소스를 보다보면 중요한 주석도 으레 그렇겠거니 하고 넘겨버리는 경우가 생긴다.
저자는 그런 경우를 조심하고자 기본 주석에 대해 부정적으로 얘기하는 것으로 보인다.
- 하지만 적절한 주석은 헤매는 개발자에게 큰 도움이 되기도 한다. 적절하게 주석을 사용하자.


 ----------------------------------
## ch5_형식 맞추기

### 형식을 맞추는 목적 : 코드형식 = 의사소통방식. 소스가 엄청나게 바뀌더라도 맨처음 잡은 구현스타일/가독성 수준은 유지보수에 계속해서 영향을 미친다.
1. 적절한 행 길이 유지 : 작은 파일이 이해하기 쉽다.
   1. 신문기사처럼 작성 : 위->아래로 읽는 방식, 표제->요약->본문 등 읽기 쉬운 양식을 유지
   2. 개념은 빈 행으로 분리
   3. 세로 밀집도 : 연관성이 높다면 세로로 가깝게
   4. 수직거리
      1. 변수 : 사용 위치에 가깝게 선언
      2. 인스턴스 변수 : 클래스 맨 처음에 선언
      3. 종속함수 : 세로로 가까이 배치
      4. 개념적 유사성 : 유사한 코드는 가까이 배치
   5. 세로순서 : 호출되는 함수를 호출하는 함수보다 나중에 배치
2. 가로형식 맞추기
   1. 가로공백과 밀집도
   2. 가로정렬 : 과도한 탭 사용으로 정렬하는것은 바람직하지 않다
   3. 들여쓰기
   4. 가짜범위
3. 팀 규칙
4. 밥아저씨의 형식규칙

### ch5 결론 : 들여쓰기에 유의하고 유사성 있는 코드들을 가까이 배치하자

### 내의견 적기
- 한 행의 가로크기를 작게 유지하면 모니터를 세로방향으로 사용해도 소스를 한눈에 볼 수 있다.
- 스크롤링해서 함수를 찾고 또 이동하는 방식이 굉장히 불편하기 때문에 가로로 소스를 짧게 짜도록 노력해보자


----------------------------------
## ch6_객체와 자료구조
1. 자료 추상화
2. 자료/객체 비대칭 : 절차적코드 <-> 객체지향 코드. 둘은 서로 상호보완적이다
3. 디미터 법칙 : 휴리스틱 법칙중 하나. 모듈은 자신이 조작하는 객체의 속사적을 몰라야 한다.
   1. 기차 충돌
   2. 잡종 구조
   3. 구조체 감추기
4. 자료객체
   1. 활성 레코드

### ch6 결론 : 객체와 자료구조의 차이점을 알고 활용한다. 
- 객체 : 동작공개+자료숨김 -> 새로운 객체타입 추가 용이 + 새 동작 추가는 어려움
- 자료구조 : 동작없음+자료노출 -> 새 동작추가 용이 + 새 자료구조 추가는 어려움

### 내의견 적기
- 저자는 bean 형태의 방식을 별다른 이익이 없다고 말하고 있다. 
- 비공개변수를 조회/설정 함수로 조작하는 자료구조체의 방식. 익숙한 방식이라 이런이유에서 부정될수 있구나를 배웠다.


----------------------------------
## ch7_오류처리
1. 오류코드보다 예외를 사용하라
2. try-cath-finally 문을 작성하라
3. 미확인(unchecked) 예외를 사용하라
4. 예외에 의미를 제공해라
5. 호출자를 고려한 예외클래스 정의
6. 정상 흐름을 정의
7. null을 반환하지 말것 : 'null 확인을 해야한다' 보다 'null이 반환/전달되지 않는다'가 더 좋은방식 
8. null을 전달하지 말것

### ch7 결론 : 예외를 잘 정리하면 비즈니스로직과 오류처리가 깔끔하게 분리될 수 있다.

### 내의견 적기
- null 확인처리는 항상 필요한 문제였다. optional을 잘 사용하면 null이 넘어가지 않도록 처리가 가능할텐데 아직 능숙하게 쓰지는 못하고 있다. 연습하자
