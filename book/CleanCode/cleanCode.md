## ch0_책의요지

## 책의 핵심 : 클린코드를 지향하는 이유. 클린코드를 위한 팀이나 공동체에서 서로 동의하는 합리적인 원칙을 세우기 위한 소통방법.

## 5s
1. Sort:정리. 정렬  => 적절한 명명법으로 정리
2. Section:정돈. 체계화 => 예상하는 위치에 예상된 코드가 있어야함
3. Seiso:청소. 광내기 => 과거이력, 미래바람, 주석으로 처리한 코드 삭제
4. Seiketsu:청결. 표준화 => 그룹이 동의한 방식으로 청소
5. shutsuke:생활화. 규율 => 관례를 따르고 또 변경에 유연할 것

## => 제품의 생명주기까지 고려할 줄 알아야 한다.

----------------------------------
## ch1_깨끗한 코드
1. 깨끗한 코드가 필요한 이유
   1. 르블랑의 법칙 : 나중은 결코 오지 않는다. 스파게티 코드를 고칠 시간은 없다.
2. 클린코드에 대한 다양한 개발자의 의견
   1. 자기 코드에 대한 장인정신을 가져야함

### ch1 결론 : 유지보수를 위해서는 처음에 잘 짜야한다. 나중에 고치자는 생각을 접고 최대한 장인정신을 가지고 코딩하자

### 내의견 적기
깃허브 코파일럿(코딩AI)은 요구사항을 정확히 이해해야 하는 인간의 상황을 알기 어려움   

----------------------------------
## ch2_의미있는 이름(네이밍)
1. 의도를 분명히 밝힐 것 
2. 그릇된 정보를 전달하지 않는 변수명 
   1. 일관성이 떨어지면 안된다
   2. i와 l, 0과 O의 혼동에 유의할 것
3. 의미있는 구분이 가능할 것 
4. 발음이 쉬울 것 
5. 검색하기 쉬울 것
6. 인코딩을 피할 것
   1. 헝가리식 표기법 
   2. 멤버변수 접두어 
      1. 함수와 클래스는 접두어가 필요없을 정도로 작아야 한다
   3. 인터페이스 클래스와 구현 클래스 
7. 자신의 기억력을 믿지 말것
8. 클래스명
   1. 명사/명사구가 적합
9. 메서드명
   1. 동사/동사구가 적합
10. 기발한 이름은 피할것
11. 한 개면에 한 단어를 사용할 것
    1. 일관성 있는 변수명 사용이 가독성을 높임
12. 말장난하지 말 것
13. 해법 영역에서 가져온 이름을 사용할 것
14. 문제 영역에서 가져온 이름을 사용할 것
15. 의미있는 맥락을 추가할 것
16. 불필요한 맥락을 없앨것

### ch2 결론 : 네이밍 룰을 정하고 따르는 것이 장기적으로 유지보수에 유리함. 직관적이고 통일적인 네이밍 사용권장.

### 내의견 적기
1. 변수/함수 네이밍에 대한 말장난은 다음 책에서 재미있게 볼수 있다
개인적으로 개발자의 깔깔유머집같은 느낌이라고 생각한다. 가볍게 웃으면서 볼수 있는 책이다

- 유지보수하기 어렵게 코딩하는 법 by 로에디 그린(부제: 평생 개발자로 먹고 살 수 있다)

2. 개발시에는 팀에서 관리하는 용어집이 있는게 좋더라
- gubun, kind, type 등 비슷한 경우에 어떤 단어를 선택할지 몰라 많은 시간이 허비된다.
- 공동 용어집이 있으면 기존에 어떤 단어를 사용했는지 알기가 훨씬 수월하다.

3. 매직넘버/매직리터럴의 사용을 피할 것
- 대부분 지역적/개인적으로 쓰이기 때문에 다른 개발자가 소스를 분석할 때 불편하다.

cf) 매직넘버와 매직리터럴
: 상수로 선언되지 않은 숫자/문자열을 말함
 ex) 
```
   if(state == 10)
   if(state == "ok")
```

 -매직넘버/스트링 제거시->
```
   if(state == NOISE_LEVEL)
   if(state == STATE_OK)
```

- 이런식으로 상수로 추출해 값이 어떤 항목인지 네이밍으로 명확하게 하고 관리도 중앙에서 할수 있는 방식이 장기적으로 유리하다.


----------------------------------

## ch3_함수
1. 작게 만들기
2. 한가지 기능만 할것
3. 함수당 추상화 수준은 하나로
   1. 위에서 아래로 내려가는 구현순서. 가독성
4. 서술적인 이름 사용
5. 함수인수
   1. 단항형식
   2. 플래그인수
   3. 이항함수
   4. 삼항함수
   5. 인수객체
   6. 인수목록
   7. 동사와 키워드
6. 부수 효과를 사용하지 말것
7. 명령과 조회의 분리
8. 오류코드보다 예외를 사용
   1. try/catch 블록 뽑아내기
   2. 오류처리도 한가지 작업
   3. Error.java 의존성 자석
9. 반복하지 말것
10. 구조적 프로그래밍
11. 함수를 짜는 법

### ch3 결론 : 함수는 작고 간결하게 구분지어 만들 것. 파라미터가 여러개인 함수는 이해하기 어렵다. 함수를 구분/단순화하자


### 내의견 적기
- 가능한 중복코드를 줄이고 함수를 구분하자. 물론 코딩하다보면 한 함수에 내용이 전부 구현되는게 편하긴한데..
바로 리팩토링을 해서라도 구분해놓는게 미래의 나/우리를 위해 좋다고 하니 노력하자

 ----------------------------------
## ch4_주석
1. 주석은 나쁜 코드를 보완하지 못한다.
2. 코드로 의도를 표현하기
3. 좋은 주석 : 극단적으로 표현하면, 코드가 명확하면 주석이 필요없다
   1. 법적인 주석
   2. 정보를 제공
   3. 의도를 설명
   4. 의미가 명료한 주석
   5. 결과를 경고하는 주석
   6. toDo주석
   7. 중요성을 강조
   8. 공개 api에서 javadocs
4. 나쁜주석
   1. 주절거리기
   2. 중복된 이야기
   3. 오해의 여지가 있는 주석
   4. 의무적으로 다는 주석
   5. 이력을 기록하는 주석 : GIT을 믿는다면 필요없다
   6. 있으나 마나한 주석
   7. 무서운 잡음 : ex) ----actions---- 등 주석으로 코드를 구분하는 경우. 
   8. 함수/변수로 표현할 수 있는 경우 주석을 달지 말것
   9. 위치를 표시하는 주석
   10. 닫는괄호에 다는 주석 : 함수가 긴 경우 유용하나 bracket 플러그인을 사용하거나 함수의 크기를 줄이는 방법을 먼저 생각하자
   11. 공로를 돌리거나/저자를 표시하는 주석
   12. 주석으로 처리한 코드 : 데드코드가 쌓여서 코드가 지저분진다.
   13. html 주석
   14. 전역정보
   15. 너무 많은 정보
   16. 모호한 관계
   17. 함수 헤더
   18. 비공개 코드에서 javaDocs

### ch4 결론 : 부정확한 주석은 없느니만 못하다 

### 내의견 적기
- 잘못 적힌 주석이나 의미없는 주석이 많은 소스를 보다보면 중요한 주석도 으레 그렇겠거니 하고 넘겨버리는 경우가 생긴다.
저자는 그런 경우를 조심하고자 기본 주석에 대해 부정적으로 얘기하는 것으로 보인다.
- 하지만 적절한 주석은 헤매는 개발자에게 큰 도움이 되기도 한다. 적절하게 주석을 사용하자.


 ----------------------------------
## ch5_형식 맞추기

### 형식을 맞추는 목적 : 코드형식 = 의사소통방식. 소스가 엄청나게 바뀌더라도 맨처음 잡은 구현스타일/가독성 수준은 유지보수에 계속해서 영향을 미친다.
1. 적절한 행 길이 유지 : 작은 파일이 이해하기 쉽다.
   1. 신문기사처럼 작성 : 위->아래로 읽는 방식, 표제->요약->본문 등 읽기 쉬운 양식을 유지
   2. 개념은 빈 행으로 분리
   3. 세로 밀집도 : 연관성이 높다면 세로로 가깝게
   4. 수직거리
      1. 변수 : 사용 위치에 가깝게 선언
      2. 인스턴스 변수 : 클래스 맨 처음에 선언
      3. 종속함수 : 세로로 가까이 배치
      4. 개념적 유사성 : 유사한 코드는 가까이 배치
   5. 세로순서 : 호출되는 함수를 호출하는 함수보다 나중에 배치
2. 가로형식 맞추기
   1. 가로공백과 밀집도
   2. 가로정렬 : 과도한 탭 사용으로 정렬하는것은 바람직하지 않다
   3. 들여쓰기
   4. 가짜범위
3. 팀 규칙
4. 밥아저씨의 형식규칙

### ch5 결론 : 들여쓰기에 유의하고 유사성 있는 코드들을 가까이 배치하자

### 내의견 적기
- 한 행의 가로크기를 작게 유지하면 모니터를 세로방향으로 사용해도 소스를 한눈에 볼 수 있다.
- 스크롤링해서 함수를 찾고 또 이동하는 방식이 굉장히 불편하기 때문에 가로로 소스를 짧게 짜도록 노력해보자


----------------------------------
## ch6_객체와 자료구조
1. 자료 추상화
2. 자료/객체 비대칭 : 절차적코드 <-> 객체지향 코드. 둘은 서로 상호보완적이다
3. 디미터 법칙 : 휴리스틱 법칙중 하나. 모듈은 자신이 조작하는 객체의 속사적을 몰라야 한다.
   1. 기차 충돌
   2. 잡종 구조
   3. 구조체 감추기
4. 자료객체
   1. 활성 레코드

### ch6 결론 : 객체와 자료구조의 차이점을 알고 활용한다. 
- 객체 : 동작공개+자료숨김 -> 새로운 객체타입 추가 용이 + 새 동작 추가는 어려움
- 자료구조 : 동작없음+자료노출 -> 새 동작추가 용이 + 새 자료구조 추가는 어려움

### 내의견 적기
- 저자는 bean 형태의 방식을 별다른 이익이 없다고 말하고 있다. 
- 비공개변수를 조회/설정 함수로 조작하는 자료구조체의 방식. 익숙한 방식이라 이런이유에서 부정될수 있구나를 배웠다.


----------------------------------
## ch7_오류처리
1. 오류코드보다 예외를 사용하라
2. try-cath-finally 문을 작성하라
3. 미확인(unchecked) 예외를 사용하라
4. 예외에 의미를 제공해라
5. 호출자를 고려한 예외클래스 정의
6. 정상 흐름을 정의
7. null을 반환하지 말것 : 'null 확인을 해야한다' 보다 'null이 반환/전달되지 않는다'가 더 좋은방식 
8. null을 전달하지 말것

### ch7 결론 : 예외를 잘 정리하면 비즈니스로직과 오류처리가 깔끔하게 분리될 수 있다.

### 내의견 적기
- null 확인처리는 항상 필요한 문제였다. optional을 잘 사용하면 null이 넘어가지 않도록 처리가 가능할텐데 아직 능숙하게 쓰지는 못하고 있다. 연습하자

----------------------------------

## ch8_경계
1. 외부코드 사용하기
2. 경계를 살피고 익히기
3. log4j
4. 학습테스트를 이용하자 : 실제 외부코드를 연결해 사용하기 전에 간단한 테스트케이스를 통해 코드를 익히는 것
5. 아직 존재하지 않는 코드를 사용하기 : 아는 코드의 영역과 모르는 영역의 코드를 분리해 작업할 것. 인터페이스 이용 등.
6. 깨끗한 경계

### ch8 결론 : 외부 패키지를 호출하는 코드를 가능한 줄여 경계를 관리해야 한다.

### 내의견 적기
- 외부 라이브러리 사용시 연동의 경계에 주의하자


----------------------------------

## ch9_단위 테스트 
1. TDD (Test Driven Development)
2. TDD 법칙 세가지
   1. 실패하는 단위테스트를 작성할 때까지 실제 코드를 작성하지 않는다
   2. 컴파일은 실패하지 않으면서 + 실행이 실패하는 정도로만 단위 테스트를 작성한다
   3. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다
3. 깨끗한 테스트코드 유지하기
   1. 유연성 제공
   2. 유지보수성 제공
   3. 재사용성 제공
4. 깨끗한 테스트코드
   1. 도메인에 특화된 테스트언어
   2. 이중표준
      1. 테스트환경의 표준과 운영환경에서의 표준이 다르다는 뜻. 테스트시에는 자원이나 효율을 따지기보다 단순/간결하면 된다는, 각 목적에 따른 표준이 다르다는 뜻.
5. 테스트당 assert 한개
   1. assert문의 사용은 줄이는 것이 좋다.
   2. 테스트당 개념 하나를 테스트할 것
6. F.I.R.S.T. : 깨끗한 테스트의 다섯가지 규칙
   1. F fast: 테스트는 빨리 돌아야한다.
   2. I independent : 각 테스트는 서로 독립적이어야 한다. 
   3. R repeatable : 테스트는 어떤 환경에서도 반복 가능해야한다.
   4. S self-validating : 테스트는 boolean 값의 결과를 내야한다. 주관적인 판단의 여지가 있어선 안된다.
   5. T timely : 테스트는 적시에 작성해야한다. 테스트가 가능한 코드가 설계되어야 한다.


### ch9 결론 : 테스트코드가 망가지면 실제 코드도 망가진다. 테스트코드는 실제코드의 유연성/유지보수성/재사용성을 보존하고 강화한다

### 내의견 적기
- 개인적으로 테스트의 중요성은 머리로는 알지만 실제 코드에 녹여내고 있지 못하고 있다.. 반성ㅜㅜ

----------------------------------

## ch10_클래스
1. 클래스 체계 : 상수 -> 변수 -> 정적 비공개변수 -> 비공개 인스턴스 변수 -> 공개함수 -> 비공개함수는 본인을 호출하는 함수 직후에 위치. 이런 기본순서가 있기때문에 클래스를 읽기 편하다. 
   1. 캡슐화
2. 클래스는 작아야한다
   1. 단일 책임원칙 : 클래스/모듈을 변경하는 이유는 하나뿐이어야 한다는 원칙.
   2. 응집도
   3. 응집도를 유지하면 -> 작은 클래스가 여러개 나온다 : 응집도가 높아지도록 변수와 메소드를 분리하면 클래스가 작아진다
3. 변경하기 쉬운 클래스
   1. 변경으로부터 격리 : 인터페이스와 추상클래스를 이용해 구현이 미치는 영향을 격리한다


### ch10 결론 : 클래스를 쪼개고 캡슐화하라. 변경으로부터 안전해질 수 있다.

### 내의견 적기
- 한개 클래스가 크면 너무 많은 역할을 하게 된다. 깨진 유리창의 법칙처럼 이미 너무 큰 클래스에 하나씩 기능이 더해지기도 한다. 그런 경우에 유의해 클래스의 간결함을 유지하자


----------------------------------

## ch11_시스템
1. 시스템 제작과 시스템 사용의 분리 : 시스템의 생성부와 사용부를 분리한다
   1. main분리 : main에서 필요 객체를 모두 생성하고 애플리케이션에서는 그 객체를 받아 사용한다
   2. 팩토리
   3. 의존성 주입
2. 확장
   1. 횡단 관심사 (cross-cutting)
3. 자바 프록시 : 개별객체나 클래스에서 메서드 호출을 감싸는 등 단순한 상황에 적합
4. 순수 자바 AOP 프레임워크 : 스프링 AOP 등. 내부적으로 프록시를 사용한다
5. AspectJ 관점 : 관심사를 관점으로 분리하는 강력한 도구
6. 테스트 주도 시스템 아키텍쳐 구축
7. 의사결정의 최적화
8. 적절한 표준의 사용
9. 시스템은 도메인 특화 언어가 필요함

### ch11 결론 : 마지막 순간에 결정난다고 생각하고 프로젝트를 간결하고 독립적이게 구현할 것. 가장 단순한 수단으로 구현하라

### 내의견 적기
- 이 챕터는 모르는 개념이 많아 어렵다.. 용어를 정리해본다.

1. 횡단 관심사 cross-cutting 용어정리
- 관심 : 입금/출금/이체 등 한개의 기능을 관심이라고 칭함.

- 횡단 관심사 : 여러개의 관심을 관통하는 공통적인 부분. 
- ex) 보안인증, 검증, 로깅, 트랜젝션 등

- 이런 공통되는 부분을 그때마다 작성하면 코드가 중복된다
### => 따라서 AOP(관점지향 프로그래밍 Aspect Oriented Programming) 이 나옴. 중복사항을 모듈화해서 관리함  