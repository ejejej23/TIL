## ch0_책의요지

## 책의 핵심 : 클린코드를 지향하는 이유. 클린코드를 위한 팀이나 공동체에서 서로 동의하는 합리적인 원칙을 세우기 위한 소통방법.

## 5s
1. Sort:정리. 정렬  => 적절한 명명법으로 정리
2. Section:정돈. 체계화 => 예상하는 위치에 예상된 코드가 있어야함
3. Seiso:청소. 광내기 => 과거이력, 미래바람, 주석으로 처리한 코드 삭제
4. Seiketsu:청결. 표준화 => 그룹이 동의한 방식으로 청소
5. shutsuke:생활화. 규율 => 관례를 따르고 또 변경에 유연할 것

## => 제품의 생명주기까지 고려할 줄 알아야 한다.

----------------------------------
## ch1_깨끗한 코드
1. 깨끗한 코드가 필요한 이유
   1. 르블랑의 법칙 : 나중은 결코 오지 않는다. 스파게티 코드를 고칠 시간은 없다.
2. 클린코드에 대한 다양한 개발자의 의견
   1. 자기 코드에 대한 장인정신을 가져야함

### ch1 결론 : 유지보수를 위해서는 처음에 잘 짜야한다. 나중에 고치자는 생각을 접고 최대한 장인정신을 가지고 코딩하자

### 내의견 적기
깃허브 코파일럿(코딩AI)은 요구사항을 정확히 이해해야 하는 인간의 상황을 알기 어려움   

----------------------------------
## ch2_의미있는 이름(네이밍)
1. 의도를 분명히 밝힐 것 
2. 그릇된 정보를 전달하지 않는 변수명 
   1. 일관성이 떨어지면 안된다
   2. i와 l, 0과 O의 혼동에 유의할 것
3. 의미있는 구분이 가능할 것 
4. 발음이 쉬울 것 
5. 검색하기 쉬울 것
6. 인코딩을 피할 것
   1. 헝가리식 표기법 
   2. 멤버변수 접두어 
      1. 함수와 클래스는 접두어가 필요없을 정도로 작아야 한다
   3. 인터페이스 클래스와 구현 클래스 
7. 자신의 기억력을 믿지 말것
8. 클래스명
   1. 명사/명사구가 적합
9. 메서드명
   1. 동사/동사구가 적합
10. 기발한 이름은 피할것
11. 한 개면에 한 단어를 사용할 것
    1. 일관성 있는 변수명 사용이 가독성을 높임
12. 말장난하지 말 것
13. 해법 영역에서 가져온 이름을 사용할 것
14. 문제 영역에서 가져온 이름을 사용할 것
15. 의미있는 맥락을 추가할 것
16. 불필요한 맥락을 없앨것

### ch2 결론 : 네이밍 룰을 정하고 따르는 것이 장기적으로 유지보수에 유리함. 직관적이고 통일적인 네이밍 사용권장.

### 내의견 적기
1. 변수/함수 네이밍에 대한 말장난은 다음 책에서 재미있게 볼수 있다
개인적으로 개발자의 깔깔유머집같은 느낌이라고 생각한다. 가볍게 웃으면서 볼수 있는 책이다

- 유지보수하기 어렵게 코딩하는 법 by 로에디 그린(부제: 평생 개발자로 먹고 살 수 있다)

2. 개발시에는 팀에서 관리하는 용어집이 있는게 좋더라
- gubun, kind, type 등 비슷한 경우에 어떤 단어를 선택할지 몰라 많은 시간이 허비된다.
- 공동 용어집이 있으면 기존에 어떤 단어를 사용했는지 알기가 훨씬 수월하다.

3. 매직넘버/매직리터럴의 사용을 피할 것
- 대부분 지역적/개인적으로 쓰이기 때문에 다른 개발자가 소스를 분석할 때 불편하다.

cf) 매직넘버와 매직리터럴
: 상수로 선언되지 않은 숫자/문자열을 말함
 ex) 
```
   if(state == 10)
   if(state == "ok")
```

 -매직넘버/스트링 제거시->
```
   if(state == NOISE_LEVEL)
   if(state == STATE_OK)
```

- 이런식으로 상수로 추출해 값이 어떤 항목인지 네이밍으로 명확하게 하고 관리도 중앙에서 할수 있는 방식이 장기적으로 유리하다.


----------------------------------

## ch3_함수
1. 작게 만들기
2. 한가지 기능만 할것
3. 함수당 추상화 수준은 하나로
   1. 위에서 아래로 내려가는 구현순서. 가독성
4. 서술적인 이름 사용
5. 함수인수
   1. 단항형식
   2. 플래그인수
   3. 이항함수
   4. 삼항함수
   5. 인수객체
   6. 인수목록
   7. 동사와 키워드
6. 부수 효과를 사용하지 말것
7. 명령과 조회의 분리
8. 오류코드보다 예외를 사용
   1. try/catch 블록 뽑아내기
   2. 오류처리도 한가지 작업
   3. Error.java 의존성 자석
9. 반복하지 말것
10. 구조적 프로그래밍
11. 함수를 짜는 법

### ch3 결론 : 함수는 작고 간결하게 구분지어 만들 것. 파라미터가 여러개인 함수는 이해하기 어렵다. 함수를 구분/단순화하자


### 내의견 적기
- 가능한 중복코드를 줄이고 함수를 구분하자. 물론 코딩하다보면 한 함수에 내용이 전부 구현되는게 편하긴한데..
바로 리팩토링을 해서라도 구분해놓는게 미래의 나/우리를 위해 좋다고 하니 노력하자

 ----------------------------------
## ch4_주석
1. 주석은 나쁜 코드를 보완하지 못한다.
2. 코드로 의도를 표현하기
3. 좋은 주석 : 극단적으로 표현하면, 코드가 명확하면 주석이 필요없다
   1. 법적인 주석
   2. 정보를 제공
   3. 의도를 설명
   4. 의미가 명료한 주석
   5. 결과를 경고하는 주석
   6. toDo주석
   7. 중요성을 강조
   8. 공개 api에서 javadocs
4. 나쁜주석
   1. 주절거리기
   2. 중복된 이야기
   3. 오해의 여지가 있는 주석
   4. 의무적으로 다는 주석
   5. 이력을 기록하는 주석 : GIT을 믿는다면 필요없다
   6. 있으나 마나한 주석
   7. 무서운 잡음 : ex) ----actions---- 등 주석으로 코드를 구분하는 경우. 
   8. 함수/변수로 표현할 수 있는 경우 주석을 달지 말것
   9. 위치를 표시하는 주석
   10. 닫는괄호에 다는 주석 : 함수가 긴 경우 유용하나 bracket 플러그인을 사용하거나 함수의 크기를 줄이는 방법을 먼저 생각하자
   11. 공로를 돌리거나/저자를 표시하는 주석
   12. 주석으로 처리한 코드 : 데드코드가 쌓여서 코드가 지저분진다.
   13. html 주석
   14. 전역정보
   15. 너무 많은 정보
   16. 모호한 관계
   17. 함수 헤더
   18. 비공개 코드에서 javaDocs

### ch4 결론 : 부정확한 주석은 없느니만 못하다 

### 내의견 적기
- 잘못 적힌 주석이나 의미없는 주석이 많은 소스를 보다보면 중요한 주석도 으레 그렇겠거니 하고 넘겨버리는 경우가 생긴다.
저자는 그런 경우를 조심하고자 기본 주석에 대해 부정적으로 얘기하는 것으로 보인다.
- 하지만 적절한 주석은 헤매는 개발자에게 큰 도움이 되기도 한다. 적절하게 주석을 사용하자.


 ----------------------------------
## ch5_형식 맞추기

### 형식을 맞추는 목적 : 코드형식 = 의사소통방식. 소스가 엄청나게 바뀌더라도 맨처음 잡은 구현스타일/가독성 수준은 유지보수에 계속해서 영향을 미친다.
1. 적절한 행 길이 유지 : 작은 파일이 이해하기 쉽다.
   1. 신문기사처럼 작성 : 위->아래로 읽는 방식, 표제->요약->본문 등 읽기 쉬운 양식을 유지
   2. 개념은 빈 행으로 분리
   3. 세로 밀집도 : 연관성이 높다면 세로로 가깝게
   4. 수직거리
      1. 변수 : 사용 위치에 가깝게 선언
      2. 인스턴스 변수 : 클래스 맨 처음에 선언
      3. 종속함수 : 세로로 가까이 배치
      4. 개념적 유사성 : 유사한 코드는 가까이 배치
   5. 세로순서 : 호출되는 함수를 호출하는 함수보다 나중에 배치
2. 가로형식 맞추기
   1. 가로공백과 밀집도
   2. 가로정렬 : 과도한 탭 사용으로 정렬하는것은 바람직하지 않다
   3. 들여쓰기
   4. 가짜범위
3. 팀 규칙
4. 밥아저씨의 형식규칙

### ch5 결론 : 들여쓰기에 유의하고 유사성 있는 코드들을 가까이 배치하자

### 내의견 적기
- 한 행의 가로크기를 작게 유지하면 모니터를 세로방향으로 사용해도 소스를 한눈에 볼 수 있다.
- 스크롤링해서 함수를 찾고 또 이동하는 방식이 굉장히 불편하기 때문에 가로로 소스를 짧게 짜도록 노력해보자


----------------------------------
## ch6_객체와 자료구조
1. 자료 추상화
2. 자료/객체 비대칭 : 절차적코드 <-> 객체지향 코드. 둘은 서로 상호보완적이다
3. 디미터 법칙 : 휴리스틱 법칙중 하나. 모듈은 자신이 조작하는 객체의 속사적을 몰라야 한다.
   1. 기차 충돌
   2. 잡종 구조
   3. 구조체 감추기
4. 자료객체
   1. 활성 레코드

### ch6 결론 : 객체와 자료구조의 차이점을 알고 활용한다. 
- 객체 : 동작공개+자료숨김 -> 새로운 객체타입 추가 용이 + 새 동작 추가는 어려움
- 자료구조 : 동작없음+자료노출 -> 새 동작추가 용이 + 새 자료구조 추가는 어려움

### 내의견 적기
- 저자는 bean 형태의 방식을 별다른 이익이 없다고 말하고 있다. 
- 비공개변수를 조회/설정 함수로 조작하는 자료구조체의 방식. 익숙한 방식이라 이런이유에서 부정될수 있구나를 배웠다.


----------------------------------
## ch7_오류처리
1. 오류코드보다 예외를 사용하라
2. try-cath-finally 문을 작성하라
3. 미확인(unchecked) 예외를 사용하라
4. 예외에 의미를 제공해라
5. 호출자를 고려한 예외클래스 정의
6. 정상 흐름을 정의
7. null을 반환하지 말것 : 'null 확인을 해야한다' 보다 'null이 반환/전달되지 않는다'가 더 좋은방식 
8. null을 전달하지 말것

### ch7 결론 : 예외를 잘 정리하면 비즈니스로직과 오류처리가 깔끔하게 분리될 수 있다.

### 내의견 적기
- null 확인처리는 항상 필요한 문제였다. optional을 잘 사용하면 null이 넘어가지 않도록 처리가 가능할텐데 아직 능숙하게 쓰지는 못하고 있다. 연습하자

----------------------------------

## ch8_경계
1. 외부코드 사용하기
2. 경계를 살피고 익히기
3. log4j
4. 학습테스트를 이용하자 : 실제 외부코드를 연결해 사용하기 전에 간단한 테스트케이스를 통해 코드를 익히는 것
5. 아직 존재하지 않는 코드를 사용하기 : 아는 코드의 영역과 모르는 영역의 코드를 분리해 작업할 것. 인터페이스 이용 등.
6. 깨끗한 경계

### ch8 결론 : 외부 패키지를 호출하는 코드를 가능한 줄여 경계를 관리해야 한다.

### 내의견 적기
- 외부 라이브러리 사용시 연동의 경계에 주의하자


----------------------------------

## ch9_단위 테스트 
1. TDD (Test Driven Development)
2. TDD 법칙 세가지
   1. 실패하는 단위테스트를 작성할 때까지 실제 코드를 작성하지 않는다
   2. 컴파일은 실패하지 않으면서 + 실행이 실패하는 정도로만 단위 테스트를 작성한다
   3. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다
3. 깨끗한 테스트코드 유지하기
   1. 유연성 제공
   2. 유지보수성 제공
   3. 재사용성 제공
4. 깨끗한 테스트코드
   1. 도메인에 특화된 테스트언어
   2. 이중표준
      1. 테스트환경의 표준과 운영환경에서의 표준이 다르다는 뜻. 테스트시에는 자원이나 효율을 따지기보다 단순/간결하면 된다는, 각 목적에 따른 표준이 다르다는 뜻.
5. 테스트당 assert 한개
   1. assert문의 사용은 줄이는 것이 좋다.
   2. 테스트당 개념 하나를 테스트할 것
6. F.I.R.S.T. : 깨끗한 테스트의 다섯가지 규칙
   1. F fast: 테스트는 빨리 돌아야한다.
   2. I independent : 각 테스트는 서로 독립적이어야 한다. 
   3. R repeatable : 테스트는 어떤 환경에서도 반복 가능해야한다.
   4. S self-validating : 테스트는 boolean 값의 결과를 내야한다. 주관적인 판단의 여지가 있어선 안된다.
   5. T timely : 테스트는 적시에 작성해야한다. 테스트가 가능한 코드가 설계되어야 한다.


### ch9 결론 : 테스트코드가 망가지면 실제 코드도 망가진다. 테스트코드는 실제코드의 유연성/유지보수성/재사용성을 보존하고 강화한다

### 내의견 적기
- 개인적으로 테스트의 중요성은 머리로는 알지만 실제 코드에 녹여내고 있지 못하고 있다.. 반성ㅜㅜ

----------------------------------

## ch10_클래스
1. 클래스 체계 : 상수 -> 변수 -> 정적 비공개변수 -> 비공개 인스턴스 변수 -> 공개함수 -> 비공개함수는 본인을 호출하는 함수 직후에 위치. 이런 기본순서가 있기때문에 클래스를 읽기 편하다. 
   1. 캡슐화
2. 클래스는 작아야한다
   1. 단일 책임원칙 : 클래스/모듈을 변경하는 이유는 하나뿐이어야 한다는 원칙.
   2. 응집도
   3. 응집도를 유지하면 -> 작은 클래스가 여러개 나온다 : 응집도가 높아지도록 변수와 메소드를 분리하면 클래스가 작아진다
3. 변경하기 쉬운 클래스
   1. 변경으로부터 격리 : 인터페이스와 추상클래스를 이용해 구현이 미치는 영향을 격리한다


### ch10 결론 : 클래스를 쪼개고 캡슐화하라. 변경으로부터 안전해질 수 있다.

### 내의견 적기
- 한개 클래스가 크면 너무 많은 역할을 하게 된다. 깨진 유리창의 법칙처럼 이미 너무 큰 클래스에 하나씩 기능이 더해지기도 한다. 그런 경우에 유의해 클래스의 간결함을 유지하자


----------------------------------

## ch11_시스템
1. 시스템 제작과 시스템 사용의 분리 : 시스템의 생성부와 사용부를 분리한다
   1. main분리 : main에서 필요 객체를 모두 생성하고 애플리케이션에서는 그 객체를 받아 사용한다
   2. 팩토리
   3. 의존성 주입
2. 확장
   1. 횡단 관심사 (cross-cutting)
3. 자바 프록시 : 개별객체나 클래스에서 메서드 호출을 감싸는 등 단순한 상황에 적합
4. 순수 자바 AOP 프레임워크 : 스프링 AOP 등. 내부적으로 프록시를 사용한다
5. AspectJ 관점 : 관심사를 관점으로 분리하는 강력한 도구
6. 테스트 주도 시스템 아키텍쳐 구축
7. 의사결정의 최적화
8. 적절한 표준의 사용
9. 시스템은 도메인 특화 언어가 필요함

### ch11 결론 : 마지막 순간에 결정난다고 생각하고 프로젝트를 간결하고 독립적이게 구현할 것. 가장 단순한 수단으로 구현하라

### 내의견 적기
- 이 챕터는 모르는 개념이 많아 어렵다.. 용어를 정리해본다.

1. 횡단 관심사 cross-cutting 용어정리
- 관심 : 입금/출금/이체 등 한개의 기능을 관심이라고 칭함.

- 횡단 관심사 : 여러개의 관심을 관통하는 공통적인 부분. 
- ex) 보안인증, 검증, 로깅, 트랜젝션 등

- 이런 공통되는 부분을 그때마다 작성하면 코드가 중복된다
### => 따라서 AOP(관점지향 프로그래밍 Aspect Oriented Programming) 이 나옴. 중복사항을 모듈화해서 관리함

----------------------------------

## ch12_창발성
1. 창발적 설계로 깔끔한 설계 구현
- 창발성 : 하위 구성요소에는 없는 특성이나 행동이 전체구조에서 자발적으로 돌연히 출연하는 현상. 불시에 솟아나는 특성(Emergence)
- 켄트 백의 단순한 설계규칙 4가지
   1. 모든 테스트를 실행한다 : 테스트케이스를 만들고 실행하라
   2. 중복제거 : 소규모 재사용을 제대로 사용하라
   3. 프로그래머의 의도 표현 
      1. 명칭으로 기능이 짐작되는 네이밍을 사용할 것
      2. 함수와 클래스 크기를 최대한 줄일 것
      3. 표준 명칭을 사용할 것
      4. 단위 테스트케이스를 꼼꼼히 작성할 것
      5. 가장중요한 것 : 노오오력!!
   4. 클래스와 메서드 수를 최소로 줄일 것
2. 리팩터링

### ch12 결론 : 응집도를 높이고/ 결합도를 낮추고/ 관심사를 분리하고/시스템 관심사를 모듈로 나누고/함수와 클래스 크기를 줄이는 등 다양한 기법을 동원해 리팩토링하라

### 내의견 적기
작은 것을 잘 정리해두면 크게 봐도 깔끔하다는 논리


----------------------------------

## ch13_동시성
1. 동시성이 필요한 이유
   - 동시성 : 결합을 없애는 전략. what과 when을 분리하는 전략.
   1. 일반적인 오해와 미신
      1. 동시성 = 성능향상 : 아니다. 일상적인 상황에서 반드시 비례하는 것은 아니다
      2. 동시성을 구현해도 설계는 변하지 않는다 : 아니다. 설계가 판이하게 다르고 달라진다
      3. 웹 또는 EJB 컨테이너를 사용하면 동시성의 이해가 필요없다 : 아니다. 컨테이너가 어떻게 동작하는지, 동시수정/데드락 같은 문제를 어떻게 피하는지 알아야한다.
   2. 동시성과 관련된 타당한 의견
      1. 동시성은 다소 부하를 유발한다 : 성능측면에서 부하가 걸리며, 코드도 더 짜야한다.
      2. 동시성은 복잡하다. 간단한 문제라도 복잡하다.
      3. 일반적으로 동시성 버그는 재현하기 어렵다. 그래서 결함으로 간주되지 않고 일회성 문제로 무시되는 경우가 잦다.
      4. 동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야한다.
2. 난관 
   - 동시성을 구현하기 어려운 이유 -> 두 스레드가 같은 변수를 동시에 참조하는 경우의 수가 바이트 코드만 고려해도 잠재적인 경로가 12870개나 있다. 대다수 경로는 바른 답을 도출한다. 
3. 동시성 방어 원칙
   1. 단일 책임원칙(SRP) : 주어진 메서드/클래스/컴포넌트를 변경할 이유는 하나여야 한다.
      1. 동시성 코드는 독자적인 개발/변경/조율 주기가 있다.
      2. 동시성 코드에는 독자적인 난관이 있다.다른코드에서 겪는 난관과 다르며 훨씬 어렵다.
      3. 잘못 구현한 동시성 코드는 다양하게 실패한다.
      
      => 권장사항 : 동시성 코드는 다른 코드와 분리하라
   2. 따름정리 : 자료 범위를 제한하라
      1. 공유객체를 사용하는 코드 내 임계영역을 syncronized 키워드로 보호하라
      
      => 자료를 캡슐화하라. 공유자료를 최대한 줄여라 
   3. 따름정리 : 자료 사본을 사용하라
      1. 공유자료를 줄이려면 처음부터 공유하지 않는 방법이 제일 좋다.
   4. 따름정리 : 스레드는 가능한 독립적으로 구현하라
      1. 다른 스레드와 자료를 공유하지 않는다
      
      => 독자적인 스레드로, 가능하면 다른 프로세스에서 돌려도 문제없도록 자료를 독립적인 단위로 분할하라
4. 라이브러리를 이해하라 : 이 책은 자바5 출시시점에 작성됨. 자바5부터 제공하는 스레드에 안전한 컬렉션을 사용할 것을 권고함.
   1. 스레드 환경에 안전한 컬렉션
5. 실행모델을 이해하라
   1. 기본 용어정리
      1. 한정된 자원(Bound Resource) : 다중 스레드 환경에서 사용하는 자원. 크기/숫자가 제한적임. 데이터베이스 연결/길이가 일정한 읽/쓰기 버퍼 등이 있음
      2. 상호 배제(Mutual Exclusion) : 한번에 한 스레드만 공유자료나 공유자원을 사용할 수 있는 경우를 말함
      3. 기아(Starvation) : 한 스레드나 여러 스레드가 오래/영원히 자원을 기다린다. ex) 짧은 스레드가 우선순위가 높은 경우 긴 스레드는 기아상태에 빠질 수 있다.
      4. 데드락(Deadlock) : 여러 스레드가 서로가 끝나기를 기다림. 모든 스레드가 각기 필요한 자원이 다른 스레드에 점유된 상태로 대기해 어느쪽도 진행되지 않는다
      5. 라이브락(Livelock) : 락을 거는 단계에서 각 스레드가 서로를 방해한다. 스레드는 계속해서 진행하려 하지만 공명(Resonance)으로 인해 오래/영원히 진행되지 않는다.
   2. 다중 스레드 프로그래밍에서 사용하는 실행모델
      1. 생산자 - 소비자(producer - consumer) : 
         1. 한개 이상 생산자 스레드가 정보를 생성해 버퍼나 대기열에 넣음. 
         2. 하나 이상의 소비자 스레드가 대기열에서 정보를 가져가 사용한다. 
         3. 각 대기열은 한정된 자원임. 생산자 스레드는 대기열에 빈 공간이 있어야 정보를 채울 수 있기 때문에 빈 공간이 생길 때까지 기다린다.
         4. 대기열의 상태를 공유하기 위해 생산자와 소비자 스레드는 서로에게 시그널을 보낸다.
         5. 이 시그널의 순서가 꼬이면 생산자 스레드/소비자 스레드가 모두 사용 가능한 상태임에도 서로의 시그널을 기다리는 대기상태에 빠질 수 있다.
      2. 읽기 - 쓰기(Readers - Writers) :
         1. 읽기 스레드가 주 정보원으로 공유자원을 사용한다
         2. 쓰기 스레드가 이 공유자원을 이따금 갱신한다
         3. 이 경우 처리율(throughput)이 핵심이다. 처리율을 강조하면 기아현상이 생기거나 오래된 정보가 쌓일 수 있다.
         4. 쓰기 스레드가 버퍼를 갱신하는 동안 읽기 스레드가 버퍼를 읽지 않으려면/ 또는 반대 경우를 방지하기 위해 복잡한 균형잡기가 필요하다.
         5. 대부분의 경우 쓰기 스레드가 버퍼를 오래 점유하는 바람에 여러 읽기 스레드가 버퍼를 기다리느라 처리율이 떨어진다.
         
         #### 해결하기 위한 전략1 : 읽기 스레드가 없을 때까지 갱신을 원하는 쓰기 스레드가 버퍼를 기다리는 방법
         1. 발생하는 문제점
            1. 읽기 스레드가 계속 이어지는 경우 쓰기 스레드가 기아상태에 빠진다
         2. 반대의 경우 : 쓰기 스레드에 우선권을 주는 방식
            1. 쓰기 스레드가 이어지는 경우 처리율이 떨어진다
         3. 두가지 경우의 균형을 잡고 동시 갱신 문제를 피하는 해법이 필요하다
      3. 식사하는 철학자들 예제
      
         : 원형 테이블에 앉은 철학자들이 공동 소유의, 갯수가 부족한 식기를 이용해 식사를 한다. 각자의 왼쪽에 포크가 하나씩 있다. 하지만 식사를 하려면 양손에 포크를 쥐어야 한다. 
         옆사람이 밥을 먹는동안 나는 밥을 먹을 수 없다.
      
         이때 효율적으로 밥을 먹는 방식을 자원을 사용하는 스레드 분배 방식에 적용해볼 수 있다.
      #### 권장사항 : 위 경우들에서 설명하는 기본 알고리즘과 해법을 이해하라  

6. 동기화하는 메소드 사이 존재하는 의존성을 이해하라 : 동기화 메서드 사이에 의존성이 있으면 동시성 코드에 찾기 어려운 버그가 발생할 수 있다. syncronized 개념이 있지만 이를 적용하기 올바른 경우인지 파악한 후 사용하자
   #### 권장사항 : 공유 객체에는 메서드 하나만 사용하라
   1. 권장사항을 적용할 수 없는 경우(공유객체 하나에 여러 메서드가 필요한 경우) 아래 방법을 고려하라
      1. 클라이언트에서 잠금 : 클라이언트에서 첫번째 메서드를 호출하기 전에 서버를 잠근다. 마지막 메서드를 호출할 때까지 잠금을 유지
      2. 서버에서 잠금 : 서버에 [서버를 잠그고 모든 메서드를 호출한 후 잠금을 해제하는 메서드]를 구현한다. 클라이언트는 이 메서드를 호출한다.
      3. 연결 서버 : 잠금을 수행하는 중간단계를 생성. '서버에서 잠금'방식과 유사하지만 원래 서버는 변경하지 않음

7. 동기화하는 부분을 작게 만들어라 : 자바는 syncronized 키워드로 락을 설정한다. 같은 락으로 감싼 모든 영역은 한번에 한 스레드만 실행한다.
   1. 락은 스레드를 지연시키고 부하를 가중시킨다 -> synronized 키워드를 남발하면 안됨
   2. 임계영역은 반드시 보호해야한다 -> 코드 작성시 임계 영역 수를 최대한 줄여야 한다
   3. 임계영역 수를 줄일 때 영역 한개의 크기를 너무 크게하면 안된다 -> 스레드간 경쟁이 늘어나고 프로그램 성능이 떨어진다
   #### 권장사항 : 동기화 부분은 작게 만들어라

8. 올바른 종료코드는 구현하기 어렵다
   1. 가장 흔한 문제 : 데드락. 스레드가 절대 오지않을 시그널을 기다린다.
   #### 권장사항 : 종료 코드를 갭라 초기부터 고민하고 동작하게 초기부터 고려하고 구현하라. 이미 있는 알고리즘들을 검토하라.
9. 스레드 코드 테스트
   #### 권장사항 : 문제를 노출하는 테스트 케이스를 만들어라. 설정과 부하를 바꿔가며 많이 테스트해라. 
    1. 말이 안되는 문제는 잠정적으로 스레드 문제로 취급하라
       1. 동시성 오류는 재현이 어렵기 때문에 일회성으로 치부되는 경우가 많다
       2. 이 일회성 문제를 무시한다면 잘못된 코드들이 쌓인다
       #### 권장사항 : 시스템 실패를 일회성으로 치부하지 마라
    2. 다중 스레드를 고려하지 않은 순차코드부터 제대로 돌게 만들어라
       1. 스레드 환경 밖에서 제대로 도는지 반드시 확인하라
       #### 권장사항 : 스레드 환경 안과 밖의 버그를 동시에 디버깅하지 마라. 스레드 환경 밖에서 먼저 점검하라
    3. 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워넣을 수 있게 스레드 코드를 구현하라
       1. 한 스레드로 실행하거나/ 여러 스레드로 실행하거나/ 실행중 스레드 수를 바꿔본다
       2. 스레드 코드를 실제 환경이나 테스트 환경에서 돌려본다
       3. 테스트 코드를 빨리/천천히 등 다양한 속도로 돌려본다
       4. 반복 테스트가 가능하도록 테스트 케이스를 작성한다
       #### 권장사항 : 다양한 설정에서 실행할 목적으로 다른 환경에 쉽게 끼울수 있는 코드를 작성하라
    4. 다중 스레드를 쓰는 코드 부분을 상황에 따라 조율할 수 있게 작성하라
       1. 스레드 수를 조율하기 쉽도록 코드를 구현한다
       2. 프로그램이 도는 도중에 스레드 개수를 변경하는 방법도 고려한다 
    5. 프로세서 수보다 많은 스레드를 돌려보라
       1. 시스템이 스레드를 스와핑할 때도 문제가 발생한다.
       2. 스와핑을 일으켜본다 -> 프로세스 수보다 많은 스레드를 돌린다.
       3. 스와핑이 잦을수록 임계영역을 빼먹은 코드나 데드락 코드를 발견하기 쉬워진다.
    6. 다른 플랫폼에서 돌려보라
       1. 운영체제마다 스레드를 처리하는 정책이 달라 결과가 달라질 수 있다. 
       #### 권장사항 : 처음부터 그리고 자주 모든 목표 플랫폼에서 코드를 돌려라.
    7. 코드에 보조 코드를 넣어 돌려라. 강제로 실패를 만들어봐라
       1. 스레드 코드의 오류는 쉽게 발견되지 않는다.
       2. 드문 오류를 자주 발생시키기 위해(그래서 고치기 위해) 보조코드를 추가해 코드의 실행순서를 바꿔준다 
          ex) Object.wait(). Object.sleep() 등의 메서드를 추가해 코드를 다양한 순서로 실행한다.
       3. 코드에 보조 코드를 추가하는 방법 : 직접 구현 또는 자동화
          1. 직접 구현하기
             1. 코드에 직접 wait(), sleep(), yield(), priority() 함수를 추가한다.
             2. 이 방법의 문제점
                1. 보조 코드를 삽입할 적정 위치를 직접 찾고 지정해야한다.
                2. 어떤 함수를 어디서 호출해야 적당한지 어떻게 알수 있지
                3. 배포 환경에 보조코드를 그대로 남겨두면 프로그램 성능이 떨어진다
                4. 무작위적임. 오류가 드러날지도/드러나지 않을 수도 있다. 사실상 드러나지 않을 가능성이 높다.
          2. 자동화
             1. AOF(Aspect-Oriented Framework), CGLIB, ASM 등의 도구를 사용한다. 
             #### 권장사항 : 흔들기 기법(실행순서의 쉐이킹)을 사용해 오류를 찾아내라

### ch13 결론 : 다중 스레드 코드는 구현하기 어렵다. 로직의 방향을 이해하고 락이 발생하지 않도록 코드를 구현해야 한다.
1. SRP를 준수하라
2. POJO를 사용해 스레드 연관/비연관 코드로 분리하라. 스레드 코드는 최대한 집약적이고 작게 만들어라
3. 동시성 오류를 일으키는 잠재적 원인을 철저히 이해하라
4. 사용하는 라이브러리와 기본 알고리즘을 이해하라
5. 보호할 코드영역을 찾는 방법과 특정 코드영역을 잠그는 방법을 이해하라. 공유할 객체와 범위를 최대한 줄여라
6. 스레드 문제를 일회성 문제로 치부하지 않도록 유의하라

### 내의견 적기
- 복잡하고 고려할 사항이 많은 챕터라 꼭지마다 저자가 권장사항을 적어두었다. 이를 염두한 코딩을 하자


----------------------------------

## ch14_점진적인 개선
- 이 챕터는 저자가 간단했던 초기 클래스에 어떤 식으로 기능/멤버가 추가되고 복잡해졌는지를 보여준다. 소스가 많으므로 책을 직접 읽는 것을 추천한다. 아래로는 리팩토링의 요소만 정리해둔다.
1. 어떤 요소가 반복되는지 분석
2. 중간단계마다 코드의 동작여부를 확인하면서 진행
3. 중복코드를 분리

### ch14 결론 : 코드가 '돌아간다'고 해서 멈추지 말 것. 리팩토링해서 최선의 상태로 코드를 유지하라

### 내의견 적기
- 저자가 말하는 것처럼 코드가 동작하는 시점에서 멈추면 안된다는 생각을 항상 해야한다. 어떤 부분을 고쳐야 할지는 처음에 알기 어렵지만 함수 나누기/중복코드 제거 등의 작은 요소부터 시작해 리팩토링을 생활화하자 
