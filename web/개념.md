# 객체지향
: 각 기능을 객체라는 기본단위로 나누고 그 객체들의 상호작용을 이용한 프로그램을 설계하고 개발하는것

## 장점
- 각 객체들의 독립적 성격 때문에 하나의 객체를 수정해도 다른 객체에 영향이 가지 않는다 = 약한 결합
- 캡슐화. 외부에서 접근이 필요한 부분을 제외하고 내용을 내부로 숨길 수 있음

## 단점
- 객체간 의존성/독립성을 생각하며 프로그래밍 해야한다 > 설계시간이 오래걸림. 실행속도가 느림

-----

# 객체지향 5원칙 SOLID
- *SRP* (Single Responsibility Principle 단일책임 원칙)
- *OCP* (Open-Closed Principle 확장개방원칙)
- *LSP* (Liskov Substitution Principle 리스코프 치환원칙)
- *ISP* (Interface Segregation Principle 인터페이스 분리 원칙)
- *DIP* (Dependency Inversion Principle 의존 역전 원칙)

##SRP 
: 한 클래스당 하나의 책임만 가져야 한다.

## OCP
: 확장에는 개방, 변경에는 폐쇄되어야 한다

## LSP
: 객체는 프로그램의 정확성을 깨지 않으면서 하위 타입으로 교체할 수 있어야한다
- 하위클래스는 상위 클래스의 한종류
- 구현 클래스는 인터페이스 할수 있어야한다

## ISP
: 클라이언트는 자신이 사용하는 메소드에만 의존관계를 가져야함

cf) 결론적으로 SPR 와 ISP는 같은 문제에 대한 두가지 해결책이다. SRP를 적용하는 것이 더 나음

## DIP
: 추상화된 것은 구체적인 것에 의존하면 안된다. 구체적 인터페이스보다 인터페이스나 추상클래스와 관계를 맺어야함

-----
#MVC
- Model

: 컨트롤러가 호출하는 컴포넌트. 실제 요청된 업무를 처리하는 비즈니스로직을 포함한다. DB에 연결해 데이터를 CRUD한다. 데이터를 처리한 후 다시 컨트롤러에 결과를 반환
- View

: 컨트롤러로부터 받은 결과데이터를 이용해 사용자가 볼 화면을 만든다.
- Controller

: 클라이언트가 요청시 그 요청을 처리할 수 있는 비즈니스 로직이 구현되어 있는 모델컴포넌트를 호출함. 클라이언트가 보낸 데이터를 모델이 전달하기 쉽게 가공한다. 이후 모델이 처리완료하면 그 결과를 VIEW에 전달한다.

-----
# 쿠키와 세션

##쿠키
: 웹사이트 접속시 생성되는 정보를 담은 임시파일. KEY-VALUE형태의 데이터. 서버가 아닌 사용자의 로컬에 저장되는 데이터

-단점 : 사용자PC에 있는 데이터기 때문에 임의로 수정가능. 보안에 약하다

##세션
: 서버에 저장되는 데이터. 웹브라우저당 한개가 생성, 웹 컨테이너에 저장된다. 웹서버에 접속한 시점~웹브라우저 종료까지 사용자의 상태를 유지시킴

## SSO
: single sing-on. 한번의 로그인으로 다른 사이트들을 자동 접속하여 이용하는 방법. 하나의 시스템에서 인증한 경우 타 시스템에서 인증정보 확인후 정보가 있으면 로그인 처리를 함.

## SSL
: Secure Socket Layer. 웹서버와 브라우저간 보안을 위해 만들어진 방법. 

## HTTP 세션 문제점

- HTTP 세션이 작성되지 않거나 요청 사이에서 삭제되었음
- HTTP 세션이 지속적이지 않습니다.
- 세션이 동일한 클라이언트 시스템의 여러 브라우저 간에 공유됩니다.
- 세션이 지정된 세션 제한시간 후 바로 무효화되지 않음
- JavaServer Pages가 원치 않는 세션을 작성하고 있습니다.
- HTTP 세션 타이머가 만기된 후 사용자가 로그아웃되지 않음
- 세션 지속성이 사용되는 애플리케이션을 업데이트할 경우 런타임 중에 예외가 발생할 수 있음

cf) 관련 참고사이트
https://www.ibm.com/docs/ko/was-zos/9.0.5?topic=sessions-http-session-problems

-----

## 웹사이트에 접근하는 흐름 = 웹통신의 흐름
- 브라우저가 url에 적힌 값을 파싱해서 HTTP Request Message를 생성, os에 전송을 요청
- 이때 도메인으로 요청을 보낼 수 없기 때문에 DNS Look up 수행
- dns lookup 과정 : 크롬의 경우 브라우저 > hosts파일 > DNS Cashe 순서로 도메인에 매칭되는 ip를 탐색
- 이 요청이 프로토콜 스택이라는 os내장된 네트워크 제어용 소프트웨어에 의해 패킷에 담기고, 패킷에 제어정보를 붙여 lan 어댑터에 전송, lan 어댑터는 이것을 전기신호로 변환해 송출
- 패킷은 스위칭 허브 등을 경유해 인터넷 접속용 라우터에서 isp로 전달, 인터넷으로 이동
- 액세스 회선에 의해 통신사용 라우터로 운반, 인터넷 핵심부로 전달
- 고속 라우터들 사이로 목적지까지 패킷이 이동
- 핵심부를 통과한 패킷은 프로토콜 스택이 패킷을 추출, 메시지를 복원하고 웹서버 어플리케이션에 넘김
- 어플리케이션은 요청에 대한 응답데이터를 작성해 클라이언트로 회송, 이 방식은 전달된 방식 역순으로 다시 전송됨.

cf) DNS
도메인 네임 시스템 : 호스트의 도메인 네임(www.naver.com)을 네트워크 주소(192.168.0.1)로 변환하거나 그 역의 역할을 수행하는 시스템
서비스 유형2가지
## 1. 신뢰할 수 있는 DNS
- 개발자가 퍼블릭 DNS 이름을 관리하는데 사용하는 업데이트 매커니즘 제공 > 이를 통해 DNS쿼리에 응답해 도메인 주소를 IP주소로 변환
- 신뢰할 수 있는 DNS는 도메인에 대한 최종권한이 있다
- 재귀적 DNS서버에 IP 주소정보가 담긴 답을 제공할 책임이 있다
## 2. 재귀적 DNS
- 보통 클라이언트는 신뢰할수있는 DNS 서비스에 직접쿼리를 수행하지 않음 > 해석기/또는 재귀적 DNS서버라고 알려진 다른유형의 DNS 서빗에 연결하는 경우가 일반적. 
- 재귀적 DNS 서비스는 호텔 컨시어지 역할. DNS레코드를 소유하고 있지 않지만 사용자를 대신해 정보를 가져올 수 있는 중간자 역할
- 캐시된 또는 저장된 DNS 레퍼러스를 가진 경우 소스나 IP를 제공하는 동작을 하거나 정보를 찾기 위해 쿼리를 다른 DNS서버에 전달함

-----
## 3Tier 계층구조
: 3계층 구조에서 각 계층은 물리적으로도 독립적이며 각 계층의 변경이 다른 계층에 의존하지 않는다..

1. 프레젠테이션(클라이언트) 계층
: 프레젠테이션 계층은 응용 프로그램의 최상위에 위치하고 있는데 이는 서로 다른 층에 있는 데이터 등과 커뮤니케이션을 한다.

- 사용자 인터페이스를 지원한다. (인터넷 브라우저의 정적인 데이터를 제공한다.)    
- 이 계층은 GUI, 또는front-end도 불린다.
- 비즈니스로직이나 데이터관리코드를 포함해서는 안된다.
- 주로 웹서버를 뜻한다(물리적 : WEB서버)
ex) HTML, javascript, CSS, image

    

2. 애플리케이션 계층
: 이 계층은 비즈니스 로직 계층 또는 트랜잭션 계층이라고도 하는데, 비즈니스 로직은 워크스테이션으로부터의 클라이언트 요청에 대해 마치 서버처럼 행동한다. 차례로 어떤 데이터가 필요한지를 결정하고, 메인프레임 컴퓨터 상에 위치하고 있을 세 번째 계층의 프로그램에 대해서는 마치 클라이언트처럼 행동한다.
- 정보처리의 규칙을 가지고 있다.(동적인 데이터를 제공한다)
- middleware 또는 back-end로 불린다.
- 프레젠테이션코드나 데이터관리 코드를 포함해서는 안된다.
- 주로 어플리케이션 서버를 뜻한다(물리적 : WAS서버)
ex) Java EE, ASP.NET, PHP

    

3. 데이터 계층
: 데이터 계층은 데이터베이스와 그것에 액세스해서 읽거나 쓰는 것을 관리하는 프로그램을 포함한다. 애플리케이션의 조직은 이것보다 더욱 복잡해질 수 있지만, 3계층 관점은 대규모 프로그램에서 일부분에 관해 생각하기에 편리한 방법이다.
- 데이터베이스를 주로 뜻한다.
- DB 또는 File System를 접근 및 관리한다.
- back-end라고도 불린다.
- 주로 DB서버를 뜻한다(물리적 : DB서버)
ex) MySQL DB, Oracle DB

------
# HTTP(Hyper Text Transfer Protocol)

## http request 메시지 스펙
- 첫줄 : 요청라인. http메서드 ex) post get
- 두번째줄 ~ 줄바꿈 전 : Header ex) User-agent, Accept
- 헤더~ 줄바꿈 이후 : Request Body

```
POST /create-developer HTTP/1.1
Content-Type: application/json
Accept: application/json

{
  "developerLevel": "JUNIOR",
  "developerSkillType": "FULL_STACK",
  "experienceYears": 2,
  "memberId": "sunny.flower",
  "name": "sun",
  "age": 36
}

```

## http response 메시지 스펙
- 첫줄 : 응답에서는 상태코드 ex) 200, 500
- 두번째줄 ~ 줄바꿈 전 : Header
- 헤더~ 줄바꿈 이후 : Response Body
```
HTTP/1.1 200 OK
Content-Type: application/json
Transfer-Encoding: chunked
Date: Sat, 17 Jul 2021 15:33:34 GMT
Keep-Alive: timeout=60
Connection: keep-alive

{
  "developerLevel": "JUNIOR",
  "developerSkillType": "FULL_STACK",
  "experienceYears": 2,
  "memberId": "sunny.flo1wer",
  "name": "sun",
  "age": 36
}

```


### 참고!!

cf) 13 년까지는 get 에 requestBody 를 보내는것이 지양되었으나 지금은 보낼 수 있음

ex) elastic search가 get 에 바디를 넣어 보내는 방식으로 사용되고 있음

-----
## URI vs URL

### URI Uniform Resource Identifier
- 하나의 리소스를 가리키는 문자열. 리소스란 http에서 요청한 대상
- URI = URL + URN 포함한 개념. 때문에 URN을 URI라고 지칭할 수 있음
- 흔히 HTTP인 것뿐 HTTP일수도 FTP일수도 있다
- 가장 흔한 URI 는 URL이다

### URL Uniform Resource Locator
- 우리가 아는 일반적인 웹주소 형식
- 리소스으 location을 가리키는데 사용됨

-----
# REST API(Representational State Transfer)

## REST 구성
- 자원(RESOURCE) - URI
- 행위(Verb) - HTTP METHOD
- 표현(Representations) - JSON, XML...

## REST 특징
1. server-client (서버-클라이언트 구조)
   1. 자원이 있는 쪽이 server, 요청하는 쪽이 client
      1. REST server : api를 제공, 비즈니스 로직 처리 및 저장을 책임진다
      2. client : 사용자 인증, context(세션, 로그인정보) 등을 직접 관리하고 책임진다
   2. 의존성이 줄어든다
2. stateless(무상태)
   1. http프로토콜은 stateless protocol. rest 역시 무상태성을 가짐
   2. client 의 context를 server에 저장하지 않음
      - 즉 세션/쿠키등 contexet정보를 신경쓰지 않아도 되므로 구현이 단순해짐
   3. 서버는 각각의 요청을 완전히 별개의 것으로 인식,처리한다.
      1. 각 api서버는 클라이언트의 요청만을 단순처리. 즉 이전요청이 다음요청의 처리에 관련되면 안된다
      2. 이전 요청이 db를 수정해 db에 의해 바뀌는 것은 허용
      3. server의 처리방식에 일관성을 부여하고 부담이 줄며, 서비스의 자유도가 높아진다
3. cacheable(캐시처리가능)
   1. 웹표준 http 프로토콜 사용하므로 웹에서 사용하는 기존 인프라를 그대로 활용가능
      1. http 가 가진 강력한 특징중 하나인 캐싱기능을 사용가능 
      2. http 프로토콜 표준에서 사용하는 last-modified 태그나 e-tag를 이용하면 캐싱 구현이 가능하다
   2. 대량요청을 효율적으로 처리하기 위해 캐시가 요구된다
   3. 캐시사용을 통해 응답시간감소, rest server 트랜잭션이 발생하지 않기 때문에 전체 응답시간, 성능, 서버의 자원이용률을 향상시킬 수 있다
4. Layered System(계층화)
   1. client 는 rest api server만 호출
   2. rest server 는 다중계층으로 구성될 수 있다
      1. api server는 순수 비즈니스 로직수행, 그앞단에 보안/로드밸런싱/암호화/사용자인증 등을 추가해 구조상 유연성을 줄 수 있다.
      2. 로드밸런싱, 공유캐시등을 통해 확장성과 보안성을 향상시킬 수 있다
   3. proxy, 게이트웨이 같은 네트워크기반 중간매체를 사용할 수 있다
5. code-on-demand(optional)
   1. server로부터 스크립트를 받아 client 에서 실행한다 > 반드시 충족할 필요는 없음
6. Uniform interface(인터페이스 일관성)
   1. uri로 지정한 resorce 에 대한 조작을 통일되고 한정적인 인터페이스로 수행한다.
   2. http 표준 프로토콜에 따르는 모든 플랫폼에서 사용가능 = 특정언어나 기술에 종속되지 않음

## REST API 설계 기본규칙

1. URI 는 정보의 자원을 표현해야 한다
2. 자원에 대한 행위는 HTTP Method(GET, PUT, POST, DELETE 등) 로 표현
   1. URI 에 HTTP METHOD 가 들어가면 안된다
   2. 경로부분중 변하는 부분은 유일한 값으로 대체한다.

## REST API 설계 규칙
1. 슬래시 구분자는 계층관계 표현에 사용한다.
2. URI 마지막 문자로 /를 포함하지 않는다
   1. URI에 포함되는 모든 글자는 리소스의 유일한 식별자로 사용되어야 하며 URI가 다르다는 것은 리소스가 다르다는 것이고, 역으로 리소스가 다르면 URI도 달라져야 한다.
   2. REST API는 분명한 URI를 만들어 통신을 해야 하기 때문에 혼동을 주지 않도록 URI 경로의 마지막에는 슬래시(/)를 사용하지 않는다.
3. -(하이픈)은  가독성을 높이는 데 사용 
4. 카멜 표기법을 사용할 수 없다.
5. _(언더바)를 사용하지 않는다
6. uri 경로에는 소문자가 적합하다. 명사형을 사용, 그중에서도 복수형을 사용하는것이 지향됨 (불가산명사의 경우 애매함이 있음)
7. 파일확장자는 uri에 포함하지 않는다  ex) Accept header 를 사용한다. 파일 다운로드같은 경우는 좀 예외사항임.

cf) 설계규칙상 그렇지만 지향점일 뿐 없다고 오류가 나는건 아님

## http method 역할

- post : 리소스 생성
- get: 리소스 조회
- put: 리소스 수정.
- patch : 리소스의 일부만 수정
- delete : 리소스 삭제

------

|리소스 | POST | GET | PUT | DELETE |
|------|------|------|-----|-----|
|/customers|새 고객 만들기 | 모든 고객 검색 | 고객 대량 업데이트 | 모든 고객 제거|
|/customers/1| |고객 1에 대한 세부정보검색 | 고객 1의 세부정보 업데이트 | 고객1제거|
|/customers/1/orders | 고객1에 대한 새주문 만들기 | 고객1에 대한 모든 주문검색  | 고객1의 주문 대량 업데이트 | 고객1의 모든 주문제거|


## 성숙도 모델
### 2008년에 Leonard Richardson은 Web API에 대한 다음과 같은 성숙도 모델을 제안

- 수준 0: 한 uri를 정의. 모든 요청
- 수준 1: 개별 리소스에 대한 별도의 uri. 용도에 맞는 구분
- 수준 2: http메서드를 사용해 리소스에 대한 작업을 정의
- 수준 3: 하이퍼미디어(HATEOAS)를 사용. ->  fielding의 정의에 따르면 이 수준이 진정한 RESTful API


- 대부분의 웹 api는 1~2 단계에 있음

-----
## REDIS
: Remote Dictionary Server. key-value 구조의 비정형 데이터를 저장하고 관리하기 위한 메모리 기반의 오픈 소스 비관계형 데이터베이스 관리 시스템(DBMS)

- WAS 인스턴스를 2개 이상 구성한 후 WAS의 JSESSIONID를 사용하게 되면, 가령 사용자가 1번 WAS 인스턴스에 접속해서 사용중에 인스턴스 장애등으로 종료 되면
2번 WAS 인스턴스로 접속할 때 기존 세션이 없으므로 새로 로그인을 해야합니다.
- 그러나 세션클러스터링을 적용하면 다수의 WAS 인스턴트중 하나에서 세션을 생성해도
모든 WAS 인스턴스와 공유되어 세션을 유지할 수 있게 됩니다.

### 이슈
####케이스1. T사
1) 그룹웨어 / 메신저 / 메일 / DB를 콘솔에서 서비스 중지 명령으로 정상 종료하는 경우
    ==> 문제없음 (세션 클러스터링 유지됨)
2) Active1- Active2 구성에서 Active1을 강제로 Shutdown(halt)시키는 경우
    ==> 문제 발생함
    ==> 답변: Redis구조상의 한계 지점이 존재한다, 
           7001, 7002, 7003을 Active1 - Active2가 Master - Slave관계로 나눠 가지고 있고
           1)번 케이스와 같이 정상적으로 서비스가 중단되는 경우에는 Master - Slave관계가 정상적으로 잘 넘겨진다.
    ==> halt같은 이상 동작의 경우에는 Master - Slave관계가 바뀌지 않아, 세션 클러스터링이 깨진다.
    ==> T사 에서는 연구소에서 기본 제공해 주신 shell (강제로 Master 권한을 가져오도록 하는)을 이용하여, Agent가 Background에서 동작하며 두 서버가 서로 살아있는지를 체크하여,
           죽었다면 Master권한을 가져오도록 보완.
※ 보완 결론: 정전 / halt등으로 한쪽 서버가 갑자기 죽는 경우, 대비책 마련 필요

####케이스2. S사
1) 4개서버당 각 2개의 WAS 인스턴스 구성으로 Redis를 적용.
2) 서버 안에 인스턴스 간에는 stop, start상황에 세션 클러스터링 되었으나 IP가 다른 서버간에는 실제 L4장비가 다른 서버로 실시간으로 스위칭 되지 않아서 중지된 서버로 접속을 시도하는 일정 시간의 딜레이가 발생.
3) 즉, 레디스를 이용한 세션 클러스터링 구성시 L4장비가 실시간으로 active한 서버로 연결이 가능한 구성인지 확인이 필요.

-> L4 장비로 다수의 그룹웨어서버를 LB 구성후 서버 장애시 절체 후 일정  시간 지연 접속에 대한 이슈는 
    L4 장비의 설정이라 Redis 장애와는 결이 다른 사항

-> 비정상적인 Redis 종료시 slave가 master로 승격이 되지 않는 이슈 Redis에서도 해당 문제를 인지하고 failover 처리를 해주는  Redis Sentinel을 기본으로 포함하여 배포중

### 참고자료
: https://smjeon.dev/web/sticky-session/

------

## 도커 Docker
: 도커(Docker)는 리눅스의 응용 프로그램들을 프로세스 격리 기술들을 사용해 컨테이너로 실행하고 관리하는 오픈 소스 프로젝트.

Docker는 컨테이너를 개발, 제공 및 실행하는 데 사용되는 컨테이너화 플랫폼입니다. Docker는 하이퍼바이저를 사용하지 않으며, 애플리케이션을 개발하고 테스트하는 경우 데스크톱 또는 노트북에서 Docker를 실행할 수 있습니다. Docker의 데스크톱 버전은 Linux, Windows 및 macOS를 지원합니다. 프로덕션 시스템의 경우 Linux 및 Microsoft Windows Server 2016 이상의 여러 변형을 포함한 서버 환경에 Docker를 사용할 수 있습니다. Azure를 포함한 많은 클라우드가 Docker를 지원합니다.

### 도커 이점
- 하드웨어의 효율적인 사용 : 컨테이너는 VM을 사용하지 않고 실행됨
- 컨테이너 격리 : 도커 컨테이너는 서로 영향을 주지않고 동일 호스트에서 여러 컨테이너를 실행하기 위한 보안기능을 제공.
- 애플리케이션 제공 : 애플리케이션을 배포하는데 사용되는 범위는 컨테이너가 됨.
- 호스팅 환경 관리 : 애플리케이션 환경은 컨테이너에 내부적으로 구성됨. 다른 컨테이너에 영향을 주지 않고 애플리케이션을 관리할 수 있음.
- 클라우드 배포 : Azure 등에서 도커 컨테이너를 배포할 수 있음

### 도커 단점
- 보안 및 가상화 : 컨테이너는 격리수준을 제공. 그러나 컨테이너는 단일 호스트 os 커널을 공유하기에 단일공격지점이 될수도 있다.
- 서비스 모니터링 : 컨테이너 내 서비스에 대한 자세한 정보를 모니터링하기 어려울 수 있음.


### ms의 도커 교육자료
https://docs.microsoft.com/ko-kr/learn/modules/intro-to-docker-containers/

### image
: docker hub에서 이미지를 풀 받고 실행하면 container라고 부름. 이때 이미지는 cd와 비슷한 개념

- docker ps : 실행중인 컨테이너 목록 조회 명령어
- docker-compose.yml : 이미지를 실행시켜주는 기능 -> 실행명령어 docker compose
- docker images : 이 레지스트리에 있는 이미지를 조회
- docker rmi : 로컬 도커 레지스트리에서 이미지를 제거

### 컨테이너 container
: 컨테이너는 소프트웨어 패키지를 빌드하고 실행할 수 있는 격리된 환경입니다. 이 소프트웨어 패키지에는 모든 컴퓨팅 환경에서 빠르고 안정적으로 애플리케이션을 실행하기 위한 코드 및 모든 종속성이 포함됩니다. 이 패키지를 컨테이너 이미지라고 합니다.
 컨테이너 이미지는 애플리케이션을 배포하는 데 사용하는 단위가 됩니다.

### 소프트웨어 컨테이너화
: 소프트웨어 컨테이너화는 VM(가상 머신)을 사용하지 않고 컨테이너를 배포 및 실행하는 데 사용되는 OS 가상화 방법입니다. 컨테이너는 물리적 하드웨어, 클라우드, VM 및 여러 OS에서 실행될 수 있습니다.

### docker 아키텍쳐
: Docker 플랫폼은 컨테이너화된 애플리케이션을 빌드, 실행 및 관리하는 데 사용하는 여러 구성 요소로 구성됩니다.

#### docker 엔진 : Docker 엔진은 클라이언트와 서버가 동일한 호스트에서 동시에 실행되는 클라이언트-서버 구현으로 구성된 여러 구성 요소로 구성됩니다. 클라이언트는 REST API를 사용하여 서버와 통신하며, REST API를 통해 클라이언트가 원격 서버 인스턴스와 통신할 수도 있습니다.
- docker 클라이언트 : Docker 클라이언트는 Docker 서버와 상호 작용하기 위한 CLI(명령줄 인터페이스)를 제공하는 docker라는 명령줄 애플리케이션입니다. docker 명령은 Docker REST API를 사용하여 로컬 또는 원격 서버에 명령을 보내고 컨테이너를 관리하는 데 사용하는 기본 인터페이스로 작동합니다.
- docker 서버 : Docker 서버는 dockerd라는 디먼입니다. dockerd 디먼은 Docker REST API를 통해 클라이언트의 요청에 응답하며 다른 디먼과 상호 작용할 수 있습니다. Docker 서버는 컨테이너의 수명 주기를 추적하는 작업도 담당합니다.
- docker 개체 : 컨테이너 배포를 지원하려면 여러 가지 개체를 만들고 구성해야 합니다. 여기에는 네트워크, 스토리지 볼륨, 플러그 인 및 기타 서비스 개체가 포함됩니다. 여기에서 이 개체를 모두 다루지는 않지만, 이 개체가 필요에 따라 만들고 배포할 수 있는 항목임을 기억하는 것이 좋습니다.

### docker hub
: Docker Hub는 SaaS(Software as a Service) Docker 컨테이너 레지스트리입니다. Docker 레지스트리는 생성되는 컨테이너 이미지를 저장하고 배포하는 데 사용하는 리포지토리입니다. Docker Hub는 Docker가 이미지 관리에 사용하는 기본 퍼블릭 레지스트리입니다.

프라이빗 Docker 레지스트리를 만들고 사용하거나, 사용 가능한 여러 클라우드 공급자 옵션 중 하나를 사용할 수 있습니다. 예를 들어 Azure Container Registry를 사용하여 여러 Azure 컨테이너 지원 서비스에서 사용할 컨테이너 이미지를 저장할 수 있습니다.

### 호스트 OS
: docker 엔진이 실행되는 OS. Linux에서 실행되는 Docker 컨테이너는 호스트 OS 커널을 공유하며 이진 파일이 OS 커널에 직접 액세스할 수 있는 한 컨테이너 OS가 필요하지 않습니다. 그러나 Windows 컨테이너에는 컨테이너 OS가 필요합니다. 컨테이너는 파일 시스템, 네트워크 관리, 프로세스 예약 및 메모리 관리와 같은 서비스를 관리하는 데 OS 커널을 사용합니다.

### 컨테이너 OS
: 패키지된 이미지에 포함된 OS. 컨테이너에는 여러 버전의 Linux 또는 Windows OS를 유연하게 포함할 수 있습니다. 이 유연성을 통해 특정 OS 기능에 액세스하거나 애플리케이션에서 사용할 수 있는 추가 소프트웨어를 설치할 수 있습니다. 컨테이너 OS는 호스트 OS와 격리되며 애플리케이션을 배포하고 실행하는 환경입니다. 이 격리는 이미지의 불변성과 결합되어 개발 시 실행되는 애플리케이션 환경이 프로덕션과 동일함을 의미합니다.

### Dockerfile : 이미지를 빌드하고 실행하는데 사용하는 지침을 포함하는 텍스트파일.
- 새 이미지를 만드는 데 사용하는 기본 또는 부모 이미지
- 기본 OS를 업데이트하고 추가 소프트웨어를 설치하는 명령
- 개발된 애플리케이션과 같이 포함할 빌드 아티팩트
- 스토리지 및 네트워크 구성과 같은 노출할 서비스
- 컨테이너가 시작될 때 실행할 명령

-----
## Lombok
: 없을때는 getter setter 전부 따로 만들어줘야했음
인텔리제이 유료버전에는 번들링되어 있음

settings > compiler > Annotation Processors 에서 Enable annotation processing 체크해줘야 사용가능
@Getter @Setter 사용시에는 접근제한자는 그다지 사용하지 않는편임

## @Setter 유의할점
- 사용자 의도에 무관하게 변환되는 경우가 없도록 유의해야함 > @builder 패턴을 사용하는 경우가 있음

## 생성자 어노테이션 3개

@NoArgsConstructor : 디폴트 생성자. protected 추천
@RequiredArgsConstructor 
@AllArgsConstructor : @builder 를 대체 사용할 것으로 권장됨

## 어노테이션들

@ToString : 주의할점 있음. 순환참조가 일어날 수 있음. 
롬복 1.8이후 exclude include 생김. 대부분 제외패턴을 많이 사용함.

@EqualsAndHashCode : hasecode 와 equals를 생성한다.
- equals : 두 객체의 내용이 같은지 동등성 비교
- haseCode: 두 객체가 같은 객체인지 동일성을 비교

@Data : 여러 어노테이션을 한번에 작성. 요즘은 사용금지. 순환참조가 일어날 수 있기 때문!

@Cleanup : 자원을 정리해줌
- java10에서 try-catch문 개선된 방식을 사용하면 @Cleanup을 사용할 필요가 없다
cf) 개선된 try-catch 방식 : Try-with-resources

@Builder : 많이 사용될 예정
컬렉션 필드에 많이 사용됨. 

cf) 디자인패턴중 빌더패턴을 많이 사용할예정

@Slf4j : 신부장님이 추천하는 방식. 로거객체를 생성한다. 

### lombok.config에 사용하지 않을 어노테이션을 관리해두면 개발자가 실수로라도 사용하지 않도록 제약을 걸 수 있다.

------

## CI/CD
CI/CD는 애플리케이션 개발 단계를 자동화하여 애플리케이션을 보다 짧은 주기로 고객에게 제공하는 방법입니다. CI/CD의 기본 개념은 지속적인 통합, 지속적인 서비스 제공, 지속적인 배포입니다. CI/CD는 새로운 코드 통합으로 인해 개발 및 운영팀에 발생하는 문제(일명 "인테그레이션 헬(integration hell)")을 해결하기 위한 솔루션입니다.
특히, CI/CD는 애플리케이션의 통합 및 테스트 단계에서부터 제공 및 배포에 이르는 애플리케이션의 라이프사이클 전체에 걸쳐 지속적인 자동화와 지속적인 모니터링을 제공합니다. 이러한 구축 사례를 일반적으로 "CI/CD 파이프라인"이라 부르며 개발 및 운영팀의 애자일 방식 협력을 통해 지원됩니다.

### CI
: 빌드/테스트 자동화 과정. 개발자를 위한 자동화 프로세스인 지속적인 통합(Continuous Integration)을의미합니다. CI를 성공적으로 구현할 경우 애플리케이션에 대한 새로운 코드 변경 사항이 정기적으로 빌드 및 테스트되어 공유 리포지토리에 통합되므로 여러 명의 개발자가 동시에 애플리케이션 개발과 관련된 코드 작업을 할 경우 서로 충돌할 수 있는 문제를 해결할 수 있습니다.
지속적 통합의 실행은 소스/버전 관리 시스템에 대한 변경 사항을 정기적으로 커밋하여 모든 사람에게 동일 작업 기반을 제공하는 것으로 시작합니다. 커밋할 때마다 빌드와 일련의 자동 테스트가 이루어져 동작을 확인하고 변경으로 인해 문제가 생기는 부분이 없도록 보장합니다. 지속적 통합은 그 자체로 유익하지만 CI/CD 파이프라인을 구현하기 위한 첫 번째 단계이기도 합니다.

### CD
: 배포 자동화 과정. CD는 지속적인 서비스 제공(Continuous Delivery) 또는 지속적인 배포(Continuous Deployment)를 의미하며 이 두 용어는 상호 교환적으로 사용됩니다. 두 가지 의미 모두 파이프라인의 추가 단계에 대한 자동화를 뜻하지만 때로는 얼마나 많은 자동화가 이루어지고 있는지를 설명하기 위해 별도로 사용되기도 합니다.
지속적 배포는 빌드, 테스트 및 배포 단계를 자동화하는 DevOps 방식을 논리적 극한까지 끌어 올립니다. 코드 변경이 파이프라인의 이전 단계를 모두 성공적으로 통과하면 수동 개입 없이 해당 변경 사항이 프로덕션에 자동으로 배포됩니다. 지속적 배포를 채택하면 품질 저하 없이 최대한 빨리 사용자에게 새로운 기능을 제공할 수 있습니다.
지속적 배포는 또한 성숙하고 입증된 지속적 통합 및 지속적인 전달 단계를 기반으로 합니다. 간단한 코드 변경이 정기적으로 마스터에 커밋되고, 자동화된 빌드 및 테스트 프로세스를 거치며 다양한 사전 프로덕션 환경으로 승격되며, 문제가 발견되지 않으면 최종적으로 배포됩니다. 강력하고 신뢰할 수 있는 자동화 배포 파이프라인을 구축하면 하루에도 여러 번 이루어지는 릴리스가 특별하지 않은 일상이 됩니다.

### CI/CD 종류
- Jenkins
- CircleCI
- TravisCI
- Github Actions
- etc