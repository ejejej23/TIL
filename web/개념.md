# 객체지향
: 각 기능을 객체라는 기본단위로 나누고 그 객체들의 상호작용을 이용한 프로그램을 설계하고 개발하는것

## 장점
- 각 객체들의 독립적 성격 때문에 하나의 객체를 수정해도 다른 객체에 영향이 가지 않는다 = 약한 결합
- 캡슐화. 외부에서 접근이 필요한 부분을 제외하고 내용을 내부로 숨길 수 있음

## 단점
- 객체간 의존성/독립성을 생각하며 프로그래밍 해야한다 > 설계시간이 오래걸림. 실행속도가 느림

-----

# 객체지향 5원칙 SOLID
- *SRP* (Single Responsibility Principle 단일책임 원칙)
- *OCP* (Open-Closed Principle 확장개방원칙)
- *LSP* (Liskov Substitution Principle 리스코프 치환원칙)
- *ISP* (Interface Segregation Principle 인터페이스 분리 원칙)
- *DIP* (Dependency Inversion Principle 의존 역전 원칙)

##SRP 
: 한 클래스당 하나의 책임만 가져야 한다.

## OCP
: 확장에는 개방, 변경에는 폐쇄되어야 한다

## LSP
: 객체는 프로그램의 정확성을 깨지 않으면서 하위 타입으로 교체할 수 있어야한다
- 하위클래스는 상위 클래스의 한종류
- 구현 클래스는 인터페이스 할수 있어야한다

## ISP
: 클라이언트는 자신이 사용하는 메소드에만 의존관계를 가져야함

cf) 결론적으로 SPR 와 ISP는 같은 문제에 대한 두가지 해결책이다. SRP를 적용하는 것이 더 나음

## DIP
: 추상화된 것은 구체적인 것에 의존하면 안된다. 구체적 인터페이스보다 인터페이스나 추상클래스와 관계를 맺어야함

-----
#MVC
- Model

: 컨트롤러가 호출하는 컴포넌트. 실제 요청된 업무를 처리하는 비즈니스로직을 포함한다. DB에 연결해 데이터를 CRUD한다. 데이터를 처리한 후 다시 컨트롤러에 결과를 반환
- View

: 컨트롤러로부터 받은 결과데이터를 이용해 사용자가 볼 화면을 만든다.
- Controller

: 클라이언트가 요청시 그 요청을 처리할 수 있는 비즈니스 로직이 구현되어 있는 모델컴포넌트를 호출함. 클라이언트가 보낸 데이터를 모델이 전달하기 쉽게 가공한다. 이후 모델이 처리완료하면 그 결과를 VIEW에 전달한다.

-----
# 쿠키와 세션

##쿠키
: 웹사이트 접속시 생성되는 정보를 담은 임시파일. KEY-VALUE형태의 데이터. 서버가 아닌 사용자의 로컬에 저장되는 데이터

-단점 : 사용자PC에 있는 데이터기 때문에 임의로 수정가능. 보안에 약하다

##세션
: 서버에 저장되는 데이터. 웹브라우저당 한개가 생성, 웹 컨테이너에 저장된다. 웹서버에 접속한 시점~웹브라우저 종료까지 사용자의 상태를 유지시킴

## SSO
: single sing-on. 한번의 로그인으로 다른 사이트들을 자동 접속하여 이용하는 방법. 하나의 시스템에서 인증한 경우 타 시스템에서 인증정보 확인후 정보가 있으면 로그인 처리를 함.

## SSL
: Secure Socket Layer. 웹서버와 브라우저간 보안을 위해 만들어진 방법. 

## HTTP 세션 문제점

- HTTP 세션이 작성되지 않거나 요청 사이에서 삭제되었음
- HTTP 세션이 지속적이지 않습니다.
- 세션이 동일한 클라이언트 시스템의 여러 브라우저 간에 공유됩니다.
- 세션이 지정된 세션 제한시간 후 바로 무효화되지 않음
- JavaServer Pages가 원치 않는 세션을 작성하고 있습니다.
- HTTP 세션 타이머가 만기된 후 사용자가 로그아웃되지 않음
- 세션 지속성이 사용되는 애플리케이션을 업데이트할 경우 런타임 중에 예외가 발생할 수 있음

cf) 관련 참고사이트
https://www.ibm.com/docs/ko/was-zos/9.0.5?topic=sessions-http-session-problems

-----

## 웹사이트에 접근하는 흐름 = 웹통신의 흐름
- 브라우저가 url에 적힌 값을 파싱해서 HTTP Request Message를 생성, os에 전송을 요청
- 이때 도메인으로 요청을 보낼 수 없기 때문에 DNS Look up 수행
- dns lookup 과정 : 크롬의 경우 브라우저 > hosts파일 > DNS Cashe 순서로 도메인에 매칭되는 ip를 탐색
- 이 요청이 프로토콜 스택이라는 os내장된 네트워크 제어용 소프트웨어에 의해 패킷에 담기고, 패킷에 제어정보를 붙여 lan 어댑터에 전송, lan 어댑터는 이것을 전기신호로 변환해 송출
- 패킷은 스위칭 허브 등을 경유해 인터넷 접속용 라우터에서 isp로 전달, 인터넷으로 이동
- 액세스 회선에 의해 통신사용 라우터로 운반, 인터넷 핵심부로 전달
- 고속 라우터들 사이로 목적지까지 패킷이 이동
- 핵심부를 통과한 패킷은 프로토콜 스택이 패킷을 추출, 메시지를 복원하고 웹서버 어플리케이션에 넘김
- 어플리케이션은 요청에 대한 응답데이터를 작성해 클라이언트로 회송, 이 방식은 전달된 방식 역순으로 다시 전송됨.

cf) DNS
도메인 네임 시스템 : 호스트의 도메인 네임(www.naver.com)을 네트워크 주소(192.168.0.1)로 변환하거나 그 역의 역할을 수행하는 시스템
서비스 유형2가지
## 1. 신뢰할 수 있는 DNS
- 개발자가 퍼블릭 DNS 이름을 관리하는데 사용하는 업데이트 매커니즘 제공 > 이를 통해 DNS쿼리에 응답해 도메인 주소를 IP주소로 변환
- 신뢰할 수 있는 DNS는 도메인에 대한 최종권한이 있다
- 재귀적 DNS서버에 IP 주소정보가 담긴 답을 제공할 책임이 있다
## 2. 재귀적 DNS
- 보통 클라이언트는 신뢰할수있는 DNS 서비스에 직접쿼리를 수행하지 않음 > 해석기/또는 재귀적 DNS서버라고 알려진 다른유형의 DNS 서빗에 연결하는 경우가 일반적. 
- 재귀적 DNS 서비스는 호텔 컨시어지 역할. DNS레코드를 소유하고 있지 않지만 사용자를 대신해 정보를 가져올 수 있는 중간자 역할
- 캐시된 또는 저장된 DNS 레퍼러스를 가진 경우 소스나 IP를 제공하는 동작을 하거나 정보를 찾기 위해 쿼리를 다른 DNS서버에 전달함

-----
## 3Tier 계층구조
: 3계층 구조에서 각 계층은 물리적으로도 독립적이며 각 계층의 변경이 다른 계층에 의존하지 않는다..

1. 프레젠테이션(클라이언트) 계층
: 프레젠테이션 계층은 응용 프로그램의 최상위에 위치하고 있는데 이는 서로 다른 층에 있는 데이터 등과 커뮤니케이션을 한다.

- 사용자 인터페이스를 지원한다. (인터넷 브라우저의 정적인 데이터를 제공한다.)    
- 이 계층은 GUI, 또는front-end도 불린다.
- 비즈니스로직이나 데이터관리코드를 포함해서는 안된다.
- 주로 웹서버를 뜻한다(물리적 : WEB서버)
ex) HTML, javascript, CSS, image

    

2. 애플리케이션 계층
: 이 계층은 비즈니스 로직 계층 또는 트랜잭션 계층이라고도 하는데, 비즈니스 로직은 워크스테이션으로부터의 클라이언트 요청에 대해 마치 서버처럼 행동한다. 차례로 어떤 데이터가 필요한지를 결정하고, 메인프레임 컴퓨터 상에 위치하고 있을 세 번째 계층의 프로그램에 대해서는 마치 클라이언트처럼 행동한다.
- 정보처리의 규칙을 가지고 있다.(동적인 데이터를 제공한다)
- middleware 또는 back-end로 불린다.
- 프레젠테이션코드나 데이터관리 코드를 포함해서는 안된다.
- 주로 어플리케이션 서버를 뜻한다(물리적 : WAS서버)
ex) Java EE, ASP.NET, PHP

    

3. 데이터 계층
: 데이터 계층은 데이터베이스와 그것에 액세스해서 읽거나 쓰는 것을 관리하는 프로그램을 포함한다. 애플리케이션의 조직은 이것보다 더욱 복잡해질 수 있지만, 3계층 관점은 대규모 프로그램에서 일부분에 관해 생각하기에 편리한 방법이다.
- 데이터베이스를 주로 뜻한다.
- DB 또는 File System를 접근 및 관리한다.
- back-end라고도 불린다.
- 주로 DB서버를 뜻한다(물리적 : DB서버)
ex) MySQL DB, Oracle DB