# 객체지향
: 각 기능을 객체라는 기본단위로 나누고 그 객체들의 상호작용을 이용한 프로그램을 설계하고 개발하는것

## 장점
- 각 객체들의 독립적 성격 때문에 하나의 객체를 수정해도 다른 객체에 영향이 가지 않는다 = 약한 결합
- 캡슐화. 외부에서 접근이 필요한 부분을 제외하고 내용을 내부로 숨길 수 있음

## 단점
- 객체간 의존성/독립성을 생각하며 프로그래밍 해야한다 > 설계시간이 오래걸림. 실행속도가 느림

-----

# 객체지향 5원칙 SOLID
- *SRP* (Single Responsibility Principle 단일책임 원칙)
- *OCP* (Open-Closed Principle 확장개방원칙)
- *LSP* (Liskov Substitution Principle 리스코프 치환원칙)
- *ISP* (Interface Segregation Principle 인터페이스 분리 원칙)
- *DIP* (Dependency Inversion Principle 의존 역전 원칙)

##SRP 
: 한 클래스당 하나의 책임만 가져야 한다.

## OCP
: 확장에는 개방, 변경에는 폐쇄되어야 한다

## LSP
: 객체는 프로그램의 정확성을 깨지 않으면서 하위 타입으로 교체할 수 있어야한다
- 하위클래스는 상위 클래스의 한종류
- 구현 클래스는 인터페이스 할수 있어야한다

## ISP
: 클라이언트는 자신이 사용하는 메소드에만 의존관계를 가져야함

cf) 결론적으로 SPR 와 ISP는 같은 문제에 대한 두가지 해결책이다. SRP를 적용하는 것이 더 나음

## DIP
: 추상화된 것은 구체적인 것에 의존하면 안된다. 구체적 인터페이스보다 인터페이스나 추상클래스와 관계를 맺어야함

-----
#MVC
- Model

: 컨트롤러가 호출하는 컴포넌트. 실제 요청된 업무를 처리하는 비즈니스로직을 포함한다. DB에 연결해 데이터를 CRUD한다. 데이터를 처리한 후 다시 컨트롤러에 결과를 반환
- View

: 컨트롤러로부터 받은 결과데이터를 이용해 사용자가 볼 화면을 만든다.
- Controller

: 클라이언트가 요청시 그 요청을 처리할 수 있는 비즈니스 로직이 구현되어 있는 모델컴포넌트를 호출함. 클라이언트가 보낸 데이터를 모델이 전달하기 쉽게 가공한다. 이후 모델이 처리완료하면 그 결과를 VIEW에 전달한다.

-----
# 쿠키와 세션

##쿠키
: 웹사이트 접속시 생성되는 정보를 담은 임시파일. KEY-VALUE형태의 데이터. 서버가 아닌 사용자의 로컬에 저장되는 데이터

-단점 : 사용자PC에 있는 데이터기 때문에 임의로 수정가능. 보안에 약하다

##세션
: 서버에 저장되는 데이터. 웹브라우저당 한개가 생성, 웹 컨테이너에 저장된다. 웹서버에 접속한 시점~웹브라우저 종료까지 사용자의 상태를 유지시킴

## SSO
: single sing-on. 한번의 로그인으로 다른 사이트들을 자동 접속하여 이용하는 방법. 하나의 시스템에서 인증한 경우 타 시스템에서 인증정보 확인후 정보가 있으면 로그인 처리를 함.

## SSL
: Secure Socket Layer. 웹서버와 브라우저간 보안을 위해 만들어진 방법. 

## HTTP 세션 문제점

- HTTP 세션이 작성되지 않거나 요청 사이에서 삭제되었음
- HTTP 세션이 지속적이지 않습니다.
- 세션이 동일한 클라이언트 시스템의 여러 브라우저 간에 공유됩니다.
- 세션이 지정된 세션 제한시간 후 바로 무효화되지 않음
- JavaServer Pages가 원치 않는 세션을 작성하고 있습니다.
- HTTP 세션 타이머가 만기된 후 사용자가 로그아웃되지 않음
- 세션 지속성이 사용되는 애플리케이션을 업데이트할 경우 런타임 중에 예외가 발생할 수 있음

cf) 관련 참고사이트
https://www.ibm.com/docs/ko/was-zos/9.0.5?topic=sessions-http-session-problems

-----

## 웹사이트에 접근하는 흐름 = 웹통신의 흐름
- 브라우저가 url에 적힌 값을 파싱해서 HTTP Request Message를 생성, os에 전송을 요청
- 이때 도메인으로 요청을 보낼 수 없기 때문에 DNS Look up 수행
- dns lookup 과정 : 크롬의 경우 브라우저 > hosts파일 > DNS Cashe 순서로 도메인에 매칭되는 ip를 탐색
- 이 요청이 프로토콜 스택이라는 os내장된 네트워크 제어용 소프트웨어에 의해 패킷에 담기고, 패킷에 제어정보를 붙여 lan 어댑터에 전송, lan 어댑터는 이것을 전기신호로 변환해 송출
- 패킷은 스위칭 허브 등을 경유해 인터넷 접속용 라우터에서 isp로 전달, 인터넷으로 이동
- 액세스 회선에 의해 통신사용 라우터로 운반, 인터넷 핵심부로 전달
- 고속 라우터들 사이로 목적지까지 패킷이 이동
- 핵심부를 통과한 패킷은 프로토콜 스택이 패킷을 추출, 메시지를 복원하고 웹서버 어플리케이션에 넘김
- 어플리케이션은 요청에 대한 응답데이터를 작성해 클라이언트로 회송, 이 방식은 전달된 방식 역순으로 다시 전송됨.

cf) DNS
도메인 네임 시스템 : 호스트의 도메인 네임(www.naver.com)을 네트워크 주소(192.168.0.1)로 변환하거나 그 역의 역할을 수행하는 시스템
서비스 유형2가지
## 1. 신뢰할 수 있는 DNS
- 개발자가 퍼블릭 DNS 이름을 관리하는데 사용하는 업데이트 매커니즘 제공 > 이를 통해 DNS쿼리에 응답해 도메인 주소를 IP주소로 변환
- 신뢰할 수 있는 DNS는 도메인에 대한 최종권한이 있다
- 재귀적 DNS서버에 IP 주소정보가 담긴 답을 제공할 책임이 있다
## 2. 재귀적 DNS
- 보통 클라이언트는 신뢰할수있는 DNS 서비스에 직접쿼리를 수행하지 않음 > 해석기/또는 재귀적 DNS서버라고 알려진 다른유형의 DNS 서빗에 연결하는 경우가 일반적. 
- 재귀적 DNS 서비스는 호텔 컨시어지 역할. DNS레코드를 소유하고 있지 않지만 사용자를 대신해 정보를 가져올 수 있는 중간자 역할
- 캐시된 또는 저장된 DNS 레퍼러스를 가진 경우 소스나 IP를 제공하는 동작을 하거나 정보를 찾기 위해 쿼리를 다른 DNS서버에 전달함

-----
## 3Tier 계층구조
: 3계층 구조에서 각 계층은 물리적으로도 독립적이며 각 계층의 변경이 다른 계층에 의존하지 않는다..

1. 프레젠테이션(클라이언트) 계층
: 프레젠테이션 계층은 응용 프로그램의 최상위에 위치하고 있는데 이는 서로 다른 층에 있는 데이터 등과 커뮤니케이션을 한다.

- 사용자 인터페이스를 지원한다. (인터넷 브라우저의 정적인 데이터를 제공한다.)    
- 이 계층은 GUI, 또는front-end도 불린다.
- 비즈니스로직이나 데이터관리코드를 포함해서는 안된다.
- 주로 웹서버를 뜻한다(물리적 : WEB서버)
ex) HTML, javascript, CSS, image

    

2. 애플리케이션 계층
: 이 계층은 비즈니스 로직 계층 또는 트랜잭션 계층이라고도 하는데, 비즈니스 로직은 워크스테이션으로부터의 클라이언트 요청에 대해 마치 서버처럼 행동한다. 차례로 어떤 데이터가 필요한지를 결정하고, 메인프레임 컴퓨터 상에 위치하고 있을 세 번째 계층의 프로그램에 대해서는 마치 클라이언트처럼 행동한다.
- 정보처리의 규칙을 가지고 있다.(동적인 데이터를 제공한다)
- middleware 또는 back-end로 불린다.
- 프레젠테이션코드나 데이터관리 코드를 포함해서는 안된다.
- 주로 어플리케이션 서버를 뜻한다(물리적 : WAS서버)
ex) Java EE, ASP.NET, PHP

    

3. 데이터 계층
: 데이터 계층은 데이터베이스와 그것에 액세스해서 읽거나 쓰는 것을 관리하는 프로그램을 포함한다. 애플리케이션의 조직은 이것보다 더욱 복잡해질 수 있지만, 3계층 관점은 대규모 프로그램에서 일부분에 관해 생각하기에 편리한 방법이다.
- 데이터베이스를 주로 뜻한다.
- DB 또는 File System를 접근 및 관리한다.
- back-end라고도 불린다.
- 주로 DB서버를 뜻한다(물리적 : DB서버)
ex) MySQL DB, Oracle DB

------
# HTTP(Hyper Text Transfer Protocol)

## http request 메시지 스펙
- 첫줄 : 요청라인. http메서드 ex) post get
- 두번째줄 ~ 줄바꿈 전 : Header ex) User-agent, Accept
- 헤더~ 줄바꿈 이후 : Request Body

```aidl
POST /create-developer HTTP/1.1
Content-Type: application/json
Accept: application/json

{
  "developerLevel": "JUNIOR",
  "developerSkillType": "FULL_STACK",
  "experienceYears": 2,
  "memberId": "sunny.flower",
  "name": "sun",
  "age": 36
}

```

## http response 메시지 스펙
- 첫줄 : 응답에서는 상태코드 ex) 200, 500
- 두번째줄 ~ 줄바꿈 전 : Header
- 헤더~ 줄바꿈 이후 : Response Body
```aidl
HTTP/1.1 200 OK
Content-Type: application/json
Transfer-Encoding: chunked
Date: Sat, 17 Jul 2021 15:33:34 GMT
Keep-Alive: timeout=60
Connection: keep-alive

{
  "developerLevel": "JUNIOR",
  "developerSkillType": "FULL_STACK",
  "experienceYears": 2,
  "memberId": "sunny.flo1wer",
  "name": "sun",
  "age": 36
}

```


### 참고!!

cf) 13 년까지는 get 에 requestBody 를 보내는것이 지양되었으나 지금은 보낼 수 있음

ex) elastic search가 get 에 바디를 넣어 보내는 방식으로 사용되고 있음

-----
## URI vs URL

### URI Uniform Resource Identifier
- 하나의 리소스를 가리키는 문자열. 리소스란 http에서 요청한 대상
- URI = URL + URN 포함한 개념. 때문에 URN을 URI라고 지칭할 수 있음
- 흔히 HTTP인 것뿐 HTTP일수도 FTP일수도 있다
- 가장 흔한 URI 는 URL이다

### URL Uniform Resource Locator
- 우리가 아는 일반적인 웹주소 형식
- 리소스으 location을 가리키는데 사용됨

-----
# REST API(Representational State Transfer)

## REST 구성
- 자원(RESOURCE) - URI
- 행위(Verb) - HTTP METHOD
- 표현(Representations) - JSON, XML...

## REST 특징
1. server-client (서버-클라이언트 구조)
   1. 자원이 있는 쪽이 server, 요청하는 쪽이 client
      1. REST server : api를 제공, 비즈니스 로직 처리 및 저장을 책임진다
      2. client : 사용자 인증, context(세션, 로그인정보) 등을 직접 관리하고 책임진다
   2. 의존성이 줄어든다
2. stateless(무상태)
   1. http프로토콜은 stateless protocol. rest 역시 무상태성을 가짐
   2. client 의 context를 server에 저장하지 않음
      - 즉 세션/쿠키등 contexet정보를 신경쓰지 않아도 되므로 구현이 단순해짐
   3. 서버는 각각의 요청을 완전히 별개의 것으로 인식,처리한다.
      1. 각 api서버는 클라이언트의 요청만을 단순처리. 즉 이전요청이 다음요청의 처리에 관련되면 안된다
      2. 이전 요청이 db를 수정해 db에 의해 바뀌는 것은 허용
      3. server의 처리방식에 일관성을 부여하고 부담이 줄며, 서비스의 자유도가 높아진다
3. cacheable(캐시처리가능)
   1. 웹표준 http 프로토콜 사용하므로 웹에서 사용하는 기존 인프라를 그대로 활용가능
      1. http 가 가진 강력한 특징중 하나인 캐싱기능을 사용가능 
      2. http 프로토콜 표준에서 사용하는 last-modified 태그나 e-tag를 이용하면 캐싱 구현이 가능하다
   2. 대량요청을 효율적으로 처리하기 위해 캐시가 요구된다
   3. 캐시사용을 통해 응답시간감소, rest server 트랜잭션이 발생하지 않기 때문에 전체 응답시간, 성능, 서버의 자원이용률을 향상시킬 수 있다
4. Layered System(계층화)
   1. client 는 rest api server만 호출
   2. rest server 는 다중계층으로 구성될 수 있다
      1. api server는 순수 비즈니스 로직수행, 그앞단에 보안/로드밸런싱/암호화/사용자인증 등을 추가해 구조상 유연성을 줄 수 있다.
      2. 로드밸런싱, 공유캐시등을 통해 확장성과 보안성을 향상시킬 수 있다
   3. proxy, 게이트웨이 같은 네트워크기반 중간매체를 사용할 수 있다
5. code-on-demand(optional)
   1. server로부터 스크립트를 받아 client 에서 실행한다 > 반드시 충족할 필요는 없음
6. Uniform interface(인터페이스 일관성)
   1. uri로 지정한 resorce 에 대한 조작을 통일되고 한정적인 인터페이스로 수행한다.
   2. http 표준 프로토콜에 따르는 모든 플랫폼에서 사용가능 = 특정언어나 기술에 종속되지 않음

