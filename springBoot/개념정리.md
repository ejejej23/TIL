# 스프링 부트는 스프링의 일부



### spring-batch > 현재 @Scheduler만 사용해봤는데 청크단위로 데이터를 잘라서 사용하는 방법도 배울예정



## 스프링 부트 특징

- 독립실행이 가능한 스프링 어플리케이션 개발 (=스탠드 얼론)

- tomcat, Jetty, Undeertyow사용한 스프링 어플리케이션 개발 

- 비동기에 최적화된 방식을 원할경우 : 제티Jetty나 언더토Undertow 사용

- 통합 starter를 제공해 maven/gradle 구성을 간소화, 자동화된 스프링 설정 제공

- 번거로운 xml설정 요구하지 않음

- jar를 이용해 자바옵션만으로도 배포가능

- spring Acurator 제공 : 모니터링할 수 있음



## 스프링부트에 대한 흔한 오해

- 스프링부트는 스프링과 다르다 > X. 스프링 부트는 스프링 프레임워크 내에서 설정을 간소화한 일부. 스프링을 모르면 스프링부트로 개발 불가.

- 토이 프로젝트까지만 사용할 수 있다 > X.  상용 프로젝트 사용가능

- 내장 was가 느리고 설정을 커스터마이징 할수없다 > X. 스프링재단 전문가들의 설정해놓은 기본설정만으로도 상용환경에서 충분한 성능 보장. cf)톰캣을 직접 설치하면 설정최적화는 필수. ex. tomcat Max Thread

cf) 스프링 설정 참고 사이트

https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#getting-started
https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#application-properties.server

### 스프링부트가 버전을 관리해주기 때문에 메이븐 등 스프링부트에서 관리해주는 항목의 버전을 pom.xml에 명시할 필요가 없다

- 스프링부트가 관리해주지 않는 항목은 버전관리 알아서 체크 해야함

## 특정 스타터를 사용하려 하는데 의존 관계가 궁금할때는 아래 사이트에서 확인
https://mvnrepository.com/


## Starter란? 

: 스프링에서는 의존관계를 개발자가 일일히 설정하지만 스프링부트에서는 스타터를 이용해 관리한다.

- 빌드에 필요한 의존성을 자동으로 관리해줌

- 특정 목적을 달성하기 위한 의존성 그룹이라고 생각하자

ex) DB연동에 스프링과 JPA가 필요하다면 메이븐은 pom.xml 에 gradle은 spring-boot starter-data-jpa 만 설정해주면 됨. 라이브러리를 일일히 찾을필요없음.



## 스타터 명명규칙 spring-boot-* 방식

ex) spring-boot-batch 

- spring-boot-starter-parent : 스프링 프레임워크가 제공하는것. 이미 많은 라이브러리가 담겨져 있다

- spring-boot-starter-parent.pom : org.springframework.boot 의 version 에 따른 각 dependency 라이브러리들의 version 이 정의됨

- dependency 내부에 version 을 명시해주면 해당 version 으로 오버라이딩 됨


* starter 어떻게 적용되는건가?

메인 자바파일에 @SpringBootApplication 어노테이션이 있다

@SpringBootApplication = @SpringBootConfiguration + @EnableAutoConfiguration + @ComponentScan


 -> 두번 읽는데 @Component 스캔해서 한번 읽고, @EnableAutoConfiguration로 한번읽음 


- @SpringBootApplication : 스프링부트의 설정을 나타냄. Spring의 @Configuration을 대체한 Spring boot 전용으로 사용되는 필수 어노테이션중 하나

- @EnableAutoConfiguration : 자동설정의 핵심. classpath 에 지정된 내용을 기반으로 설정 자동화를 수행. 설정값을 따로 지정해주지 않으면 기본값으로 동작.

- @ComponentScan : @ComponentScan 어노테이션이 달린 클래스~하위클래스를 모두 스캔해서 @Configuration, @Repository, @Service, @Controller, @RestController가 달린 클래스를 찾아서 빈으로 등록

cf) @ComponentScan의 basePackages 프로퍼티값에 별도로 경로를 설정하지 않으면 @ComponentScan이 위치한 패키지가 basePackages의 루트 경로로 설정됨(자기 자신보다 상위에 있는 패키지나 클래스는 읽을 수 없다는 의미)
