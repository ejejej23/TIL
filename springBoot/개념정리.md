# 스프링 부트는 스프링의 일부



### spring-batch > 현재 @Scheduler만 사용해봤는데 청크단위로 데이터를 잘라서 사용하는 방법도 배울예정



## 스프링 부트 특징

- 독립실행이 가능한 스프링 어플리케이션 개발 (=스탠드 얼론)

- tomcat, Jetty, Undeertyow사용한 스프링 어플리케이션 개발 

- 비동기에 최적화된 방식을 원할경우 : 제티Jetty나 언더토Undertow 사용

- 통합 starter를 제공해 maven/gradle 구성을 간소화, 자동화된 스프링 설정 제공

- 번거로운 xml설정 요구하지 않음

- jar를 이용해 자바옵션만으로도 배포가능

- spring Acurator 제공 : 모니터링할 수 있음



## 스프링부트에 대한 흔한 오해

- 스프링부트는 스프링과 다르다 > X. 스프링 부트는 스프링 프레임워크 내에서 설정을 간소화한 일부. 스프링을 모르면 스프링부트로 개발 불가.

- 토이 프로젝트까지만 사용할 수 있다 > X.  상용 프로젝트 사용가능

- 내장 was가 느리고 설정을 커스터마이징 할수없다 > X. 스프링재단 전문가들의 설정해놓은 기본설정만으로도 상용환경에서 충분한 성능 보장. cf)톰캣을 직접 설치하면 설정최적화는 필수. ex. tomcat Max Thread

cf) 스프링 설정 참고 사이트

https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#getting-started
https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#application-properties.server

### 스프링부트가 버전을 관리해주기 때문에 메이븐 등 스프링부트에서 관리해주는 항목의 버전을 pom.xml에 명시할 필요가 없다

- 스프링부트가 관리해주지 않는 항목은 버전관리 알아서 체크 해야함

## 특정 스타터를 사용하려 하는데 의존 관계가 궁금할때는 아래 사이트에서 확인
https://mvnrepository.com/


## Starter란? 

: 스프링에서는 의존관계를 개발자가 일일히 설정하지만 스프링부트에서는 스타터를 이용해 관리한다.

- 빌드에 필요한 의존성을 자동으로 관리해줌

- 특정 목적을 달성하기 위한 의존성 그룹이라고 생각하자

ex) DB연동에 스프링과 JPA가 필요하다면 메이븐은 pom.xml 에 gradle은 spring-boot starter-data-jpa 만 설정해주면 됨. 라이브러리를 일일히 찾을필요없음.



## 스타터 명명규칙 spring-boot-* 방식

ex) spring-boot-batch 

- spring-boot-starter-parent : 스프링 프레임워크가 제공하는것. 이미 많은 라이브러리가 담겨져 있다

- spring-boot-starter-parent.pom : org.springframework.boot 의 version 에 따른 각 dependency 라이브러리들의 version 이 정의됨

- dependency 내부에 version 을 명시해주면 해당 version 으로 오버라이딩 됨


* starter 어떻게 적용되는건가?

메인 자바파일에 @SpringBootApplication 어노테이션이 있다

@SpringBootApplication = @SpringBootConfiguration + @EnableAutoConfiguration + @ComponentScan


 -> 두번 읽는데 @Component 스캔해서 한번 읽고, @EnableAutoConfiguration로 한번읽음 


- @SpringBootApplication : 스프링부트의 설정을 나타냄. Spring의 @Configuration을 대체한 Spring boot 전용으로 사용되는 필수 어노테이션중 하나

- @EnableAutoConfiguration : 자동설정의 핵심. classpath 에 지정된 내용을 기반으로 설정 자동화를 수행. 설정값을 따로 지정해주지 않으면 기본값으로 동작.

- @ComponentScan : @ComponentScan 어노테이션이 달린 클래스~하위클래스를 모두 스캔해서 @Configuration, @Repository, @Service, @Controller, @RestController가 달린 클래스를 찾아서 빈으로 등록

cf) @ComponentScan의 basePackages 프로퍼티값에 별도로 경로를 설정하지 않으면 @ComponentScan이 위치한 패키지가 basePackages의 루트 경로로 설정됨(자기 자신보다 상위에 있는 패키지나 클래스는 읽을 수 없다는 의미)

## 내장 was의 이해

스프링부트는 서버가 아니다!

내장 서블릿 컨테이너나 스프링 프레임워크를 사용하기 쉽게 해주는 툴이다.

기본적으로 의존성에 톰캣이 들어있음. Netty, Jetty, Undertow로 변경해 사용가능



## 분리되어 있는 ServletWebServerFactoryAutoConfiguration 과 DispatcherServletAutoConfiguration

: 서블릿 컨테이너는 설정에 따라 달라질 수 있지만 서블릿은 변하지 않음.

DispatcherServlet은 어떤 서블릿 컨테이너를 쓰든 상관없이 서블릿을 만든다음에 현재의 서블릿 컨테이너에 등록하는 과정이 ServletWebServerFactoryAutoConfiguration에서 수행됨


## 톰캣이 아니라 다른 was로 바꾸고 싶은 경우

기본적으로 톰캣을 운영형태로 가지고 있는 부분들이 있기 때문에 새로운 was추가 + 톰캣을 제거해주는 작업을 해줘야함(예시는 메이븐 방식)

```
 톰캣제거 exclusion 사용

<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-web</artifactId>
  <exclusions>
    <exclusion>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-tomcat</artifactId>
    </exclusion>
  </exclusions>
</dependency>


 톰캣이 아닌 다른 was중 undertow 로 변경

<dependency> 
  <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-undertow</artifactId>
</dependency>
```

## jar 실행되는 원리

스프링부트는 BOOT-INF 에 jar들을 넣어놓음

mainclass : jar런처. 아래 경로의 jar파일들을 읽어들이고 그려줌 디폴트 was설정포함.

standalone으로 쓸때는 jar배포, 고객사에는 war배포 하는 방식으로도 사용가능하다.

(war가 묶어서 배포하면  was가 풀어준다)


## YAML 파일 매핑

어노테이션 사용한 2가지 방법 : @ConfigurationProperteis 사용 / @Value

### @ConfigurationProperteis 의 장점이 많아 이걸 주로 사용함

- 빈으로 등록해서 다른 빈에 주입할 수 있음

- 변수 명명방식(카멜, 케밥, 언더스코어)에 대한 융통성있는 바인딩

- 여러 프로퍼티를 묶어서 읽어올 수 있음 

- 프로퍼티 타입 컨버전 @DurationUnit

- 프로퍼티 값 검증 @Validated

- 메타 정보 생성

- @Value는 한개 변수만 가져오고, SpEL 사용할 수 있지만 @ConfigurationProperteis의 장점은 사용할 수 없음

- 스프링부트는 메타데이터에 프로퍼티들이 작성되어 있어서 읽어들이는 방식을 사용


---------------------------

## 스프링의 핵심 pojo



pojo : 순수한 자바로 돌아가자

### pojo가 되기 위한 조건

- 특정 규약에 종속되지 않는다

- ioc di(의존성 주입)같은경우 개발자가 직접 생성하지 않고 스프링등의 컨테이너를 통해 생성



장점 :
모듈간 결합도가 낮아짐. 



ioc : new 등으로 생성햇던 객체 방식을 ioc 에게 일임함.



## 스프링 컨테이너

스프링 ioic컨테이너 안에 디비 여러개 + 클래스 여러개

- 사용하는 이유 : 지금까지 많은 스프링 개발자들이 최적의 인젝션 방법 등이 들어있음





bean 종류 두가지

- java bean : bean/vo 같은 기본객체. 데이터를 저장하기 위한 구조체

- spring bean : 스프링 ioc 에 의해 생성/관리되는 객체. 



spring bean의 장점

- 의존성 관리. ioc 컨테이너가 의존성 관리를 자동으로 해주기 때문

- 라이프사이클 인터페이스를 지원해줌. ex)@PostConstruct 등 

- bean의 스코프 : 싱글톤/프로포토 타입 두가지로 나뉨. 

    싱글톤 : 처음실행될때 한번 만들어짐. 그후부터는 만들어져 있는 객체를 사용

    프로토타입 : 매번 객체를 생성.  ex) Request, Session, WebSocket 등의 방식이 있음



### applicationcontext
: ioc 컨테이너에 있는 중요한 인터페이스



### 의존성주입3가지



생성자 주입방식

- 생성자 주입방식을 가장많이 사용한다. 가장 권장되는 방법.

- 생성자에 @Autowired를 줌

- null을 주지 않는 한 nullpointer Exception이 발생하지 않음

- final로 선언이 가능함. spring은 기본적으로 클래스를 싱글톤으로 생성함

- 다른 주입방식들은 필드인젝션 보장이 안됨

- 단위테스트 작성시 테스트가 쉬움

- spring 4.3부터 생성자가 하나면 @Autowired 가 생략 가능함. 



- 필드주입같은 경우는 순환참조가 발생해도 컴파일단계에서 찾아내기 어려움
